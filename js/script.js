"use strict"; // включим строгий (современный) режим кода JS


/// ПЕРЕМЕННЫЕ

// Объявим переменную используя ключевое слово let 

/* let number = 10; // number - это имя переменной; знак = это знак присваиваивания; */
// 10 - это значение перпеменной, которе мы ей присвоили
// let обозначает, что наша переменная изменяема, т.е. мы можем изменить переменную,
// присвоив ей другое значение
// Пример:
// Обратимся к имени переменной number и присвоим ей другое значение
/* number = 55;
console.log(number); // выдаст 55, т.е. мы изменили значнеие переменной с 10 на 55 */

//Обяъвим переменную используя ключевое слово const 
/* const number1 = 20; // number1 - это имя переменной; знак = это знак присваиваивания; */
// 20 - это значение перпеменной, которе мы ей присвоили
// const обозначает, что наша переменная не изменяема, т.е. константа мы не можем 
// изменить переменную, присвоив ей другое значение
// Пример:
// Обратимся к имени переменной number1 и попробуем присвоить ей другое значение
/* number1 = 77;
console.log(number1); // выдаст ошибку TypeError: Assignment to constant variable. */
// Хорошим тоном в написание кода на JS является задание переменных через const везде, 
// где это возможно.
// Прямых констант в JS не существует и мы можем изменть значение переменной,
// заданной через const
// Пример:
// Создадим перменную с именем obj и положим в нее объект со парй ключ: значение
/* const obj = {
	a: 50
};

obj.a = 20; // После чего обратимся к свойству а объекта obj и изменим его значение
console.log(obj); // Выдаст { a: 20 }, т.е. мы поменяли значение свойства a c 50 на 20
// внутри объекта, который был присвоен как значение переменной obj */

// Имя переменной может состоять из букв, цифр, символов доллара $ и нижнего подчеркивания _
// Переменные записанные в разном регистре - это разные переменные: number Number и NUMBER
// Первый символ никогда не должен быть цифрой!!!
// Названия перменных не должны повторять зарезервированные слова в языке JS, например error,
// promt, alert и др.
// Перменные состоящие из нескольких слов записываются в формате CammelCase
// Важно назвать переменные осмысленно, ведь над ним в будущем будут работать другие люди

// Переменные let const видны только в блоке кода ограниченного круглыми скобками
// создадим объект и поменстим в него переменную
/* {
	let visible1 = 'noVisible';
	const visible = 'noVisible';
	console.log(visible, visible1); // получим noVisible noVisible - все ок
} */

// console.log(visible, visible1); // если запросим за пределами {}
// то получим ощибку visible is not defined т.е переменная не найдена


// Старый формат записи имени переменных и его проблемы

// Ранее для обозначения переменных использовалось ключевое слово var
// Данный формат записи переменных ни при каких обстоятельствах 
// мы не должны использовать в своем коде

/* console.log(name); // пытаясь оюратиться к переменной до ее объявления мы получим 
undefined var name = 'Ivan'; */
// Т.е. мы получаем не ошибку, а undefined данная переменная видна еще до ее объявления
// такое поведение при использование var называется hoisting (всплытие переменных)
// данное поведение может привести к очень не приятным и трудно отлавливаемым ошибкам

// Переменная созданная с помощью var видна и за пределами блока кода 
// ограниченного {}, т.е. переменная как бы "всплывает" в глобальную область видимости
// и это очень плохо с точки зрения логики
/* {
	var current = 10;
}
console.log(current); //выдаст 10 т.е. ошибки не будет т.к перменная "всплыла"  
// в глобальную область видимости */

// В старом стандарте JS можно было создать переменную без ее объявления через ключевое слово
// var
// Пример
/* a = 20;
console.log(a); */


// Современный формат записи кода используя директиву 'use strict';
// Данная деректива всегда записывсается в начале JS файла и говорит ему 
// что мы работатем в современном режиме JS, где уже не работают некоторые неточности,
// которые были в с тарых стандартах JS

// В новом формате используя строгий режим мы не можем объявлять переменные 
// не используя ключевых слов let или const
// Пример
/* "use strict";
 b= 20;
console.log(b); // получим ошибку ReferenceError: b is not defined */


/// ТИПЫ ДАННЫХ В JS

// Первая категория типов данных - простые типы(примитивы)

// Числа -  1, 2, 3
// Строки "string" - "name" это набор данных, которые мы можем описать словами
// Логический тип (bololean) - true / false это либо правда либо ложь
// null - специфический тип данных, это когда чего то-то просто не существует
// undefined - специфический тип данных, когда что-то существует, но у него нет значения
// Symbol -  представляет собой уникальный идентификатор.
// BigInt - тип данных отображающий большие числа (больше чем 2 в 53 степени)

// Вторая категория типов данных - комлексные типы или Объекты

// Подкатегория 1 - Спец объекты:          // Подкатегория 2 - Обычные объекты       
// Массивы []
// Функции function ()
// Объект даты
// Регулярные выражения
// Ошибки

// Разберем каждый из типов данных в частности:


// Тип данных Числа 

/* let number2 = 2;
let number3 = 4.5; // для дробных чисел используется именно точка, а не запятая */
// К числам относятся числовые значения, которые относятся к данному типу данных
// Пример
// Infinity (бесконечность) - числовое значение, получаемое при делении числа на 0
/* console.log(4 / 0); // выдаст Infinity (бесконечность)
console.log(-4 / 0); // выдаст -Infinity (минус бесконечность), получим при делении */
// отрицательно числа на 0
// NaN (Not a Number - не число)  - числовое значение получаемое в результате операции, 
// которая не подлежит математической логике
/* console.log(4 * "qwerty"); //выдаст NaN (не число)
// НО!!!
console.log(4* "111"); //выдаст строку '444' ВАЖНО помнить об этом!!! */


// Тип данных Строки

// Обязательным отрибутом строки являются кавычки, такие как: 
// Одинарные '', 
// Двойные "",
// Косые (бэктики) `` (косые кавычки используются для интерполяции 
// строк `qwerty ${43}`)

// Какаие кавычки использовать одинарные или двойные определяется стилистикой проекта,
// либо правилами заведенными в компании

/* const persone = "Alex"; */
// используя оператор typeof проверим тип данных присвоенных переменной persone
// Оператор typeof возвращает строку, указывающую тип операнда.
/* console.log(typeof(persone)); //выдаст "string" - строка */

/* const persone2 = `David`; // задание строк с помощью косых кавычек
console.log(typeof(persone2)); //выдаст "string" - строка */

/* const number4 = "888";  //строки помгу содержать в себе и цифры
// в случае если мы запишем цифры в кавычках, то тип данных у них будет не number, а string
console.log(typeof(number4)); //выдаст "string" - строка */


// Тип данных Логический тип данных bololean

/* const bool = true; // правда
const bool2 = false; // ложь */


// Тип данных null

// null - специфический тип данных, это когда чего то-то просто не существует

// Не объявляя перменную something попробуем вывести ее в консоль

/* console.log(something); // получим ошибку ссылочного типа 
// ReferenceError: something is not defined
// т.е. код не может сослаться на несуществующую переменную something */


// Тип данных Undefined 

//undefined -специфический тип данных, когда что-то существует, но у него нет значения

/* let a; // мы объявили переменную, но не присовили ей никакое значение 
console.log(a); // консоль нам выдаст undefined, т.е. перменная есть, 
//но ее значнеие не найдено */


// Тип данных Объект

// Объект - это коллекция данных, ключевая единица в JS
// данную струкутуру можно использовать для хранения абсолютно любых типов данных.
// Данные в объекте хранятся в формате ключ: значение и называются свойствами объекта.
// Так же в объекте могут содержаться какие-то дейсвтия - они называюися методы.
// Для создания объектов используются {}

/* const obj = {
	a: 23,
	b: "qwerty",
	c: [1, 3, 'asdfg'],
	isMaried: false
};  */
// Для доступа к определенному значению свойства объекта, мы долны обратиться к нему через
// имя объекта, а далее через точку указать ключ
// или черз квадратные скобки указать ключ заключенный в кавычки
// Пример
/* console.log(obj.a);  // через точку обращаемся к значению свойтсва a  - выдаст 23
console.log(obj['a']); // // через ['a'] обращаемся к значению свойтсва a  - выдаст 23 */

// Чтобы обратиться к элементу массива, который является значением определенного
// свойства объекта нужно так же указать имя объекта, затем через точку имя своства, 
// а затем в квадратных скобках указать порядковый индекс элемента массива
/* console.log(obj.c[2]); //выдаст строку 'asdfg'
// Так же можно это сделать используя только квадратные скобки
// Пример
console.log(obj["c"][1]); //выдаст число 3 */

// Частным случаем объекта явлется МАССИВ

// ВАЖНО!!! Массив это НЕ отдельный тип данных, а именно частный случай объекта
// Массив -это структура для хранения данных, которые идут СТРОГО!!! по по порядку
// Во внутрь массива, точно так же как и во внутрь объекта можно положить любой тип данных
/* let arr = ['pic1.png', 'pic2.png', 'pic3.png', 'pic4.png', {}, [], 454, NaN]; */

// Для того, чтобы обратиться к определенному элементу массива нужно указать его имя, 
// а затем в квадратных скобках указать порядковый индекс элемента этого массива
// Пример

/* console.log(arr[4]); // выдаст элемент массива arr с порядковым индексом 4 - это 
// пустой объекn {}
console.log(arr[0]); // выдаст элемент массива arr с порядковым индексом 0 - это 
// строка 'pic1.png' */
// ВАЖНО!!! В программировании нумерация начинается не с единицы (1), а с нуля (0)

//Для доказательства, что массив это частный случай объекта, а не отдельный тип данных
//рассмотрим его более детально

//Объект преставляет собой стурктуру с данными хранящимися в формате ключ: значение

// В массиве ключами будут являться его порядковые индексы 0, 1, 2, 3, 4 и т.д.
// А значенимями свойств будут являться сами элменты массива 
/* //свойства:  ключ №0      ключ №1     ключ №2     ключ №3    ключ №4
let arr1 = ['pic1.png', 'pic2.png', 'pic3.png', 'pic4.png',    {},        [], 454, NaN]; */


/// ВЗАИМОДЕЙСТВИЕ С ПОЛЬЗОВАТЕЛЕМ

// Способ №1 с помощью функции интерфейсa браузера alert

// Функция интерфейса браузера alert показывает сообщение в модальном окне браузера 
// и ждёт, пока пользователь нажмёт кнопку «ОК».
// Функция интерфеса alert чаще всего используется для того, 
// чтобы предупредить пользователя о чем-то важном.
// ВАЖНО!!! отметить, что данная функция будет работать ТОЛЬКО в браузере,
// в консоли VSCode она работать не будет. Вылетающее окно будет невозможно застилизовать.

/* alert("Привет user"); // вылетит модальное окно со строкой "Привет user" и кнопокой Ok */

// Способ №2 с помощью функции интерфейсa браузера confirm

// Функция интерфейса confirm отображает модальное окно с текстом вопроса question 
// и двумя кнопками: OK и Отмена.
// ВАЖНО!!! отметить, что данная функция будет работать ТОЛЬКО в браузере,
// в консоли VSCode она работать не будет. Вылетающее окно будет невозможно застилизовать.

/* confirm("Вам есть 18 лет?"); // вылетит модальное окно со строкой-вопросом
// "Вам есть 18 лет?" и кнопоками Ok и Отмена */

//Так же мы можем записать ответ пользователя в перменную

/* const result = confirm("Вам есть 18 лет?");
// после чего полученные данные мы сможем использовать в дальнейшем
console.log(result); // в консоли будет булиновое значение или 
// true в случае, если пользователь нажмет кнопку Ok или 
// false в случае, если пользователь нажмет кнопку Отмена */

// Способ №3 с помощью функции интерфейсa браузера prompt

// Функция интерфейса prompt отобразит модальное окно с текстом, 
// полем для ввода текста и кнопками OK/Отмена.
// Данная функция необходима, для получения информации от пользователя,
// которую он введет в поле для ввода текста. Полученную инфу можно будет записать в 
// переменную и использовать ее в дальнейшем, к примеру внося инфу в БД.

/* const answer = prompt("Сколько будет 2 + 2?", ""); // после вопроса пользователю */
// мы ставим запятую, окрываем ковычки и оставляем их пустыми, либо
// вставляем дефолтный ответ (placeholder), который пользователь сможет стереть 
//и написать свой ответ.
// Пример 
/* const answer1 = prompt("Сколько будет 2 + 2?", "4, 5 или 6?");
console.log(answer);
console.log(answer1);
// ВАЖНО!!! Все данные приходящие от пользователя всегда будут иметь тип данных string
// вне зависимости от способа их получения.
console.log(typeof(answer1)); // выдаст string - тип строка */

// Для того чтобы преобразовать строковый тип данных string в числовой number
// можно использовать оператор унарный плюс +, который ставится напрмер перед комадой prompt
// Унарный + ставится всегда перед чем-то. 
// Унарный + использует только один аргумент для своей работы
/* const answer2 = +prompt("Сколько будет 5 + 12?", "4, 5 или 6?");

console.log(typeof(answer2)); // выдаст number
console.log(answer2 + 4); // если пользователь введет число то в консоль выдаст результат
// сложения числа которе ввел пользователь и 4. */

// Зададим вопросы пользователю и запишем его ответы в массив arr2
/* const arr2 = [];
// По порядку обратимся к порядковым индексам массива arr2 и запишем в них данные
// полученные от пользователя
arr2[0] = prompt("Как Вас зовут?", ""); 
arr2[1] = +prompt("Cколько вам лет?", ""); 
arr2[2] = prompt("Какие языки программирования вы знаете?", "");
arr2[3] = +prompt("Сколько лет вы программируете на JS", "");

console.log(arr2); // в консоль выведем получивышийся массив arr2 c ответами пользователя
console.log(typeof(arr2)); // выведет object, что еще раз подтверждает, что массив - это
// частный случай объекта. */

// Одним из первых методов используемых в JS был document.write
// Метод document.write – один из наиболее древних методов добавления текста к документу, но
// заменяет все содержимое сайта и в реальных проектах не используется.
// Мы можем использовать данный метод для тестов, чтобы к примеру вывести на страницу массив
// с ответами от пользователя.
/* document.write(arr2); */
// ВАЖНО!!! Функции интерфейса alert, confirm и prompt блокируют построение страницы до того
// момента пока они не будут выполнены. 

// ВАЖНО!!! Оффтоп НО, если вывести тип данных переменной, которой присвоен 
// специфический тип данных null обозначающий то, чего не существует консоль нам высдаст 
// object
/* const nothing = null;
console.log(typeof(nothing));
// ЭТО ЯВЛЯЕТСЯ ПРИЗНАННОЙ ОШИБКОЙ В JS. null является отдельным специфическим типом данных. */


/// ИНТЕРПОЛЯЦИЯ в JS

// Ранее для того, чтобы вставить в строку значнеие переменной использовалась
//конкатенация (склеивание) строк.
// Пример
// Для того чтобы сформировать URL путь в отдельную категорию игрушки пропишем следующее
/* const category = "toys";
//Теперь выведем в консоль путь в категорию игрушки старым методом используя конкатенацию
console.log("https://www.storeyourtoys.com/" + category);  */

// Интерполяция позволяет вставлять во внутрь строки значение пеперменной при помощи
// косых ковычек и ${}
// Cформируем тот же самый путь в категорию игрущки используя интерполяцию и вставим значение
// переменной category непосредственно в саму строку используя косые кавычки (бэктики) и ${}
/* console.log(`https://www.storeyourtoys.com/${category}`); */

// Используя интерполяцию можно получить данные от пользователя, записать их в переменную,
// а затем вставить значние переменной например в alert.
/* const nameUser = prompt("Как тебя зовут?", "");
alert(`Привет, ${nameUser}!`);
*/


/// ОПЕРАТОРЫ В JS

// Оператор + стоит особняком среди других операторов таких как:

// сложения +, 
// вычетания -,
// умножения *,
// деления /

// Если оператор сложения + применить к 2-ум строкам, то эти две строки склеятся между
// собой. 
// Даже если к строке прибавить число, на выходе будет срока.
// Данная операция называется конкатенация (склеивание).

// Пример

/* const row1 = "this is row one";
console.log(row1 + " this is row two"); //строка из переменной row1 склеится 
// со строкой " this is row two", на выходе будет this is row one this is row two
console.log(row1 + 1); // на выходе будет this is row one1. 
console.log(typeof(row1 + 1)); // Выдаст string - строка */
// Если мы захотим преобраховать строку в число, посредством унарного +, 
// и сложим получившееся число с другим числом, то

/* console.log(+"row3" + 4); //на выходе получим NaN (не число) т.к. мы выполняем дейтсвие,
// которое не подлежит математической логике, 
// т.к. мы пытаемся преобразовать буквы в число. */

//Но если мы попытаемся преобразовать число с типом данных string и прибавть к нему другое 
// число, у нас все получится
/* console.log(+"5" + 4); // на выходе получим 9, т.к. 5-ка из строки превратилась в число */

// Операторы инкремента ++ и декремента --

// Операторы инкремента ++ и декремента -- слжат для укорочения нашего кода

// Оператор инкремента ++ увеличивает значение на единицу

// Оператор декремента -- уменьшает значение на единицу

// Важно!!! Частый вопрос на собесодованиях - 
// Чем отличается перфиксная форма записи инкремента и декремента от постфиксной

// Оветим на данный вопрос на примере

/* let incr = 5,
	decr = 10;

incr++; // постфиксная форма записи инкремента
decr--; // постфиксная форма записи декремента

console.log(incr); // на выходе будет 6
console.log(decr); // на выходе будет 9

++incr; // префиксная форма записи инкремента
--decr; // префиксная форма записи декремента

console.log(incr); // на выходе будет 6
console.log(decr); // на выходе будет 9 */

// и вроде как отличий никаких нет НО!!!

//САМОЕ ВАЖНОЕ!!!
//Если мы поставим знаки инкремента и декремента прямо во время их использования в console.log
// картина будет совсем иная

/* let incr1 = 10,
	decr1 = 20;

console.log(incr1++); // на выходе будет 10, т.е. ничего не извменится
console.log(decr1--); // на выходе будет 20, т.е. ничего не извменится

// НО ЕСЛИ ЗАПУСТИТЬ console.log еще раз

console.log(incr1++); // на выходе уже будет 11, т.е. инкремент уже сработал 
console.log(decr1--); // на выходе уже будет 19, т.е. инкремент уже сработал  */ 
	 
// В случае, если мы используем инкремент и декремент в постфиксной форме записи
// прямо сразу в console.log или еще где-то, то сначала
// нам возвращается первоначалльное значение, а затем уже увеличенное или 
// уменьшенное на единицу

// В префиксной форме записи ситацация совершенно противоположная.
// Нам СРАЗУ возвращается увеличиенное или уменьшенное на единицу значение

/* let incr2 = 10,
	decr2 = 20;

console.log(++incr2); // на выходе будет 11
console.log(--decr2); // на выходе будет 19 */

// В циклах оперторы инкремента и декремента будут использоваться очень часто. 

// Как и в математике в JS применятся операторы 

// больше >
// меньше <
// больше либо равно >=
// меньше либо равно <=
// равно ==              // в JS одинарный знак = это оператор присваивания, а не сравнения
// не равно != (не строгое сравнение) !== (строге сравнение учитывая тип данных)
// логический оператор И - записывается как два амперсанта &&
// логический оператор ИЛИ - записывается как два вертикальных слеша ||
// побитовые опреаторы (в данном курсе мы их затрагивать не будем)
// Оператор отрицания ! обращает значение на противополжное, правду в ложь, ложь в правду
// возврат остатка от деления двух чисел %



// Пример использования возврата остатка от деления двух чисел %

/* console.log(5 % 2); // на выходе будет 1, т.к. 5-ка делится на 2 ровно 2 раза, в остатке 1 */

// Подробнее об операторе не строгого равенства == и строгого равенства ===

// Не строгое сравнение == это когда при сравнении не учитывается тип данных

/* console.log(2 * 4 == "8"); // на выходе будет true, т.е. тип данных не учитывается, 
// учитывается только значнеие и число 8 равно сроке со значением 8. */

// Строгое сравнение === это когда при сравнении учитывается тип данных

/* console.log(2 * 4 === "8"); // на выходе будет false т.к. тип данных уже учитывается, 
// и число 8 не равно сроке со значением 8. */

// Подробнее об логических опретаторах И && и ИЛИ ||

// Логический оператор И && работает только тогда, когда два или больше значений 
// являются правдивыми выражениями, т.е. И это правда И это правда

// Пример
// Проверим, что какая-то галочка на странице отмечена, и какое-то модальное окно закрыто
/* const isChecked = true,
	  isClosed = true;
console.log(isChecked && isClosed); // на выходе будет true, т.к. и первое выражение правдиво
// и второе выражение правдиво. */

/* // В случае если 
const isChecked1 = true,
	  isClosed1 = false;
console.log(isChecked1 && isClosed1); // на выходе будет false, т.к. первое выражение правдиво,
// а второе выражение уже не правдиво. */

/* const isChecked2 = false,
	  isClosed2 = false;
console.log(isChecked2 && isClosed2); // на выходе будет false, т.к. и первое выражение 
// не правдиво, и второе выражение не правдиво. */

// Логический оператор ИЛИ || работает тогда, когда одно из значений 
// является правдивым выражением, т.е. ИЛИ это правда ИЛИ это правда

/* const isChecked3 = true,
	  isClosed3 = true;
console.log(isChecked3 || isClosed3); // на выходе будет true, т.к. первое выражение правдиво,
// а второе выражение уже не важно правдиво или нет. */

/* const isChecked4 = false,
	  isClosed4 = true;
console.log(isChecked4 || isClosed4); // на выходе будет true, т.к. второе выражение правдиво,
// а певрое уже не важно правдиво или нет. */

/* const isChecked5 = false,
	  isClosed5 = false;
console.log(isChecked5 || isClosed5); // на выходе будет false, т.к. и первое выражение 
// не правдиво, и второе выражение не правдиво. */

// Оператор отрицания !

//Оператор отрицания ! обращает булинове значение в противоположное, 
//правду в ложь, ложь в правду
/* console.log(!(false)); // на выходе будет true
console.log(!(true)); // на выходе будет false */

// Оператор не равно !=

/* console.log(2 + 2 * 2 != "6"); // на выходе получим false, т.к. если не учитывать тип данных
// то число 6 равно строке "6" */

/* console.log(2 + 2 * 2 !== "6"); // на выходе получим true, т.к. если учитывать тип данных
// и сравнивать строго, то число 6 не равно строке "6" */

/* console.log(2 + 2 * 2 != 7); // на выходе получим true, т.к. число 6 не равно числу 7 */

// Порядок выполнения операторов
// Табличка приоритетов использования кодом операторов
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table


/// СИСТЕМА КОНТРОЛЯ ВЕРСИЙ Git и СЕРВИС ХРАНЕНИЯ УДАЛЕННЫХ РЕПОЗИТОРИЕВ GitHub

// Git - это система контроля версий для проектов и создания контрольных точек.
// GitGub - это удаленное хранилище репозиториев.
// Система Git позволяет сохранять контрольные точки буквально за несколько команд  
// Все контрольные точки и изменения в проекте можно сохранять в репозитории, который позволит:
// посмотреть где, что и когда было изменено в проекте
// откатиться на старую версию проекта
// снова вернуться на новую версию проекта
// Так же Git позволяет экономить память, т.к. статичные (не измененные) файлы не копируются
// снова и снова.
// С репозиторием могут работать несколько человек, над большими реальными проектами, как 
// правило, трудится целая команда разработчиков.

// Даже если работать над проектом в одно лицо, сохранение изменений в репозиторий чрезвычайно
// важно, т.к. с компом может случиться все что угодно, либо закзачик может попросить вернуть
// те изменения, которые были несколько месяцев назад.

//Порядок установки Git'a

// 1) Скачать последнюю версию Git c сайта https://git-scm.com/
// 2) Туториал как пользоваться Git'ом можно посмотреть на https://githowto.com/ru
// 3) После установки Git'a можно юзать GUI (Графический интерфейс пользователя) 
// данное меню появляется если нажать правой кнопокой на любом файле (способ не удобен)
// 4) Можно использовать командную строку cmd. Чтобы попасть в нужную папку, а затем
// использовать Git c ее содержимым нужно набрать команду cd и через пробел указть путь
// который ведет к нужным файлам.
// 5) Вместо командной строки cmd, можно так же использовать PowerShell.
// 6) !!! НО Мы будем юзать Git прямо в VSCode!!!

// В VScode есть тот же интерфейс что и в командной строке cmd или PowerShel
// Отвечает за это вкладка Терминал.

// Порядок работы с Git'ом
// 1) Для инициализация работы Git'а в терминале набираем команду git init
// мы получим ответ Initialized empty Git repository in и в папке с проектом паявится 
// скрытая папка .git - это и есть наш репозиторий.
// 2) Необходимо законфигурировать файлы проекта:
// Конфигурировать файлы мы можем как локально так и глобально
// Глобальная конфигурация (настройки для всех файлов компьютера) позволяет создвать все 
// проекты от нашего имени.
// Локальная конфигурация (настройки для файлов отдельного проекта) позволяет создвать 
// проект указав уже любое доругое имя разработчика проекта. 
// При указании локальной конфигурации для конкретного проекта глобальные 
// данные уже не будут распространяться на него.

// Пропишем две конфигурационные команды, чтобы представить себя:
// Для локальной конфигурации прописываем следующее 
// git config --local user.name "F1icker"
// git config --local user.email fl1ck@yandex.ru (уже без кавычек)

// Для глобальной конфигурации прописываем следующее 
// git config --global user.name "F1icker"
// git config --global user.email fl1ck@yandex.ru (уже без кавычек)

// У Git репозитория есть три состояния файлов 
// 1-ое состояние - это когда фалы просто созданы
// 2-ое состояние - это когда Git следит за определенными файлами (файлы попали в index)
// 3-е состояние файлов - это когда Git создал контрольную точку к которой мы сможем вернуться
// и посмотреть какие были изменения, как работал проект в данной контрольной точке и т.д.
// Данное состояние называется commit

// Для того чтобы посмотреть в каком состоянии находятся фалы в проекте пропишем команду
// git status

// Красным цветом подсвечены все файлы, которые етсь в проекте, 
// Git за ними не следит (состояние 1)

// Чтобы переключить ветку с master на main необходимо прописать команду 
// git branch -M main

// Чтобы перевести файлы проекта во 2-ое состояние (добавить их в index) пропишем команду
// git add -A 
// Все файлы за которыми Git не следил, будут добавлены в отслеживание их цвет станет зеленым
// Если к примеру нужно добавить в отслеживание новые файлы пропишем команду
// git add имяНовогоФайла.расширениеФайла
// или 
// git add *.расширение файла (тогда будут добавлены все не остлеживающиеся фалы с данным
// расширением)
// Чтобы сбросить последнее измененеие файла можно пропсаить команду
// git restore имяНовогоФайла.расширениеФайла, это аналог сочетнаия клавишь Ctrl+Z

// Чтобы перевести файлы в 3-е состояние и создать контрольную точку пропишем команду
// git commit -a -m"first commit"
// Чтобы сбросить последний commit до предыдущего commit'a можно прописать команду
// git checkout имяНовогоФайла.расширениеФайла

// Чтобы посмотреть какие commit'ы были сделаны пропишем команду 
// git log

// Для выгрузки commit'ов на удаленный репозиторий в GitHub нужно:
// 1) Для начала нужно в учетке GitHub создать новый репозиторий
// 2) Прописать имя репозитория
// 3) Прописать описание Description(не обязательно)
// 4) Выбрать профиль репозитория Публичный Public (доступен всем) или Приватный Private
// 5) Прописываем удаленный репозиторий, в который будут выгружены наши Commit'ы
// для этого прописываем команду 
// git remote add origin https://github.com/F11cker/JS_lecture_notes.git
// После ввода данной команды наш локальный репозиторий (на нашем компе) 
// будет связан с удаленным репозиторием на GitHub
// Чтобы запушить commit'ы на GitHub прописываем команду
// git push -u origin main

// Кратко все команды по порядку:

// git config --local user.name "F1icker" (только в начале работы над новым проектом)
// git config --local user.email fl1ck@yandex.ru (уже без кавычек) (только в начале работы)
// git status 
// git branch -M main
// git add -A 
// git commit -a -m"first commit"
// git log
// git remote add origin https://github.com/F11cker/JS_lecture_notes.git (только в начале работы)
// git push -u origin main (для следующих commit'ов можно импользовать команду git push)

// Работа с репозиторием на GitHub с разных аккаунтов
// Например с работа с репозиторием с домашнего компа и с рабочего

// 1) Клонирование репозитория с которым ведется работа
// Для этого есть два способа:
// Способ №1 - зайти на GitHub в нужный репозиторий и внутри нажать зеленую кнопку
// Code и далее скачать ZIP архив с проектом
// Способ №2 с зайти в терминал VSCode и восопользваться командой 
// git clone + путь к репозиторию который мы хотим скопировать
// для того, чтобы клонировать данный репозиторий. (Это наиболее правильный способ)
// Для того, чтобы зайти в нужную папку на том компе, на которм в данный момент ведется работа
// нужно набрать следующие команды в терминале:
// cd..
// cd имяНужнойПапки
// git clone https://github.com/F11cker/JS_lecture_notes.git  имяНужнойПодПапки
// Клонирование репозитория автоматически связывает новый локальный комп 
// с удаленным репозиторием. 
// Тем самым мы сразу можем делать commit'ы в проекте и пушить их в данный удаленный реп.
// Для этого можно сразу набирать команду 
// git push

// 2) Чтобы при возвращении на, к примеру, домашний компьютер получить все те изменения проекта,
// которые были сделаны на рабочем компьютере и работать с его последней версией нужно ВСЕГДА
// перед началом работы прописывать команду 
// git pull
// В случае, если мы не пропишем команду git pull перед началом работы с проектом и попытаемся
// запушить созданные нами commit'ы мы получим ошибку, т.к. в удаленном репозитории может
// оказаться более новая версия проекта чем у нас на компьютере, на которым мы в данный момент
// работаем.
// ВСЕГДА ПРОПИСЫВАЙ git pull ПЕРЕД НАЧАЛОМ РАБОТЫ!!!

// В случае если вознимает ситуация слияния (Merge) локального и удаленного репозитория то 
// 1) Задаем сообщение commit'a
// 2) Прожимаем 2 раза Ctrl + C
// 3) Прописываем команду :wq! + Enter
// 4) Git push

// Игнорирование файлов при работе Git и GitHub (используем файл .gitignore)

// При работе с проектом, чаще всего мы не хоим пушить в удаленный репозиторий различные 
// рабочие файлы напрмер папку node_modules

/// ПРАКТИКА №1

// Задание на урок:

//1) Создать переменную numberOfFilms и в неё поместить ответ от пользователя на вопрос:
// 'Сколько фильмов вы уже посмотрели?'

//2) Создать объект personalMovieDB и в него поместить такие свойства:
	// - count - сюда передается ответ на первый вопрос
	// - movies - в это свойство поместить пустой объект
	// - actors - тоже поместить пустой объект
	// - genres - сюда поместить пустой массив
	// - privat - в это свойство поместить boolean(логическое) значение false

//3) Задайте пользователю по два раза вопросы:
	// - 'Один из последних просмотренных фильмов?'
	// - 'На сколько оцените его?'
// Ответы стоит поместить в отдельные переменные
// Записать ответы в объект movies в формате: 
/*     movies: {
		'logan': '8.1'
	} */

// Проверить, чтобы все работало без ошибок в консоли 

// Выполним задачу №1
/* const numberOfFilms = +prompt("Сколько фильмов вы уже посмотрели?", "");
// Выполним задачу №2
const personalMovieDB = {
	count: '',
	movies: {},
	actors: {},
	genres: [],
	privat: false
};

personalMovieDB.count = numberOfFilms;
// Выполним задачу №3
const lastFilms = prompt("Один из последних просмотренных фильмов?", ""),
	  rating = +prompt("На сколько оцените его?"),
	  lastFilms1 = prompt("Один из последних просмотренных фильмов?", ""),
	  rating1 = +prompt("На сколько оцените его?");

personalMovieDB.movies[lastFilms] = rating; 
personalMovieDB.movies[lastFilms1] = rating1;
// Записывать данные в объект который лежит внутри другого объекта лучше через [], 
// а не через точку.
console.log(personalMovieDB); // выведем все в консоль. */

/// УСЛОВИЯ в JS

// Все условия начинаются с оператора if (если)

// if (в круглых скобках пишем условие, которое хотим проверить) {
		// в фигурных скобках записываем то, что случится, если условие верно (true)
		// напрмер console.log("ok!");
// } else {   // Вторая часть условия начинается с else (иначе)
	// в фигурных скобках записываем то, что случится, если условие if не верно (false)
	// напрмер console.log("НЕ ok!");
// }
// Т.е. услвие внутри круглых скобок должно быть преобразованно к булиновому типу true / false

// Пример
if (9 == 9) {
	console.log("ok!");
} else {
	console.log("Error!");
}

// В случае, если в условие поместить одно число, отличное от 0, 
// то оно будет всегда будет возвращать true. 
// Число отличное от 0 в своем логическом контексте всегда true

// Пример
if (4) {
	console.log(true); // вернет true
} else {
	console.log(false);
}

// Но если поместить 0, то оно вернет false 
// 0 в своем логическом контексте всегда false 
// Пример
if (0) {
	console.log(true); 
} else {
	console.log(false); // вернет false
}

// Вложенность условий

const num = 50;

if (num < 49) {
	console.log("Error!"); 
} else if (num > 100) { // условие if не правда, проверяем следующее (это и есть вложенность)
	console.log("too much!");
} else {
	console.log("Ok!");
}                   

// Запись условий при помощи тернарного оператора

// Тернарный  оператор - единственный оператор в JavaScript, 
// принимающий три операнда: условие, за которым следует знак вопроса (?), 
// затем выражение, которое выполняется, если условие истинно (true), 
// сопровождается двоеточием (:), и, наконец, выражение, которое выполняется, 
// если условие ложно (fasle). 
// Он часто используется в качестве укороченного варианта условного оператора if.
// Синтаксис следующий:
// В круглых скобках пишем условие, которое хотим проверить
// После знака вопроса ? прописывается то, что произойдет, если условие вернет true
// После знака двоеточия : прописывается то, что произойдет, если условие вернет false

// Пример
/* const num1 = 40;
(num1 === 40) ? console.log("Ok!") : console.log("Error!");  */

///////////////////////////////////////////////////////////////////////////////////////////
// ВАЖНЫЙ ОФТОП

// 4 + 4 // в данном случае + это бинарный оператор (принимает 2 операнда)

// +"4"  // в данном случае + это унарный оператор (унарный плюс) (принимает 1 операнд)

// условие ? выражение1 : выражение2 // ? и : в совокупности являются тернарным оператором
////////////////////////////////////////////////////////////////////////////////////////////

// Конструкиця switch. 
// ВАЖНО!!! Конструкция switch ВСЕГДА ИДЕТ НА СТРОГОЕ СРАВНЕНИЕ!!! ===
// Для того чтобы избежать большого количества вложенности условий существую конструкция
// switch, которая поддерживает сразу неслько проверок и условий
// Синтаксис следующий
// В круглые скобки(в условие) мы помещаяем объект того что мы будем сравнивать
// и что проверять (просто передаем имя переменной)
// В фигурных скобках прописываем директиву case и через пробел записываем то, 
// с чем будем сравнивать значение нашей переменной.
// Ставим знак двоеточия : и после него пишем то, что произойдет если условие вернет true
// После каждого действия мы должны записать ключевое слово break и ставить знак ;
// В конце записывается действие по умолчанию default, которое сработает, 
// если не один из case'ов не вернет true.
// После так же прописываем break;

const num2 = 50;
switch (num2) {
	case 49:
		console.log("error");
		break;
	case 100:
		console.log("error");
		break;
	case 50:
		console.log("ok!");
		break;
	default: 
		console.log("nothing");
		break;  
}

// Со строками все работает точно так же, идет строгое сравнение.


/// Циклы

// Циклы - простой способ сделать какое-то однотипное действие несколько раз.

// В JS реализовываются 3-мя способами. Каждый из них исппользуется в зависимости от ситуации

// Способ №1 цикл while
// Дословно - ПОКА условие выполняется мы будем повторять какие-то действия
// Цикл while похож на условия.
let num3 = 50;

while(num3 <= 55) {     // в круглых скобках мы записываем условие
	console.log(num3); // в фигурных скобках мы записываем действия, которые будут выполняться 
	num3++;            // циклом пока условие не выполнится          
  
}

// Способ 2 цикл do
// Цикл do Сначала что-то делает, затем проверяет условия, и если необходимо выходит из цикла

let num4 = 80;

do {                   // сначала пишем ключевое слово do
	console.log(num4); // в фигурных скобках прописываем действия, которые будет выполнять цикл
	num4++;
} while(num4 < 85);    //Проверку условия размещаем под телом цикла

// Способ 3
// Цикл for - самый распространённый цикл 
// Синтаксис следующиий
// Пишем ключевое слово for
// Далее в круглых скобках прописываем условие состоящиее из 3-ех аргументов
// 1-ый аргумент это let i (итератор) задаем переменную с которой нвчинается цикл for
// 2-ой аргумент i < 8 (как пример) - это условие, при котором цикл for остановит свою работу
// 3-ий аргуммент - это шаг цикла for чаще всего используется инкремент. Пример i++
let num5 = 100;

for (let i = 0; i < 8; i++) {  // между аргументами условий цикла обязательно ставится знак ;
	console.log(num5);         // в круглых скобках записываются действия, 
	num5++;                    // которые будет выполнять цикл на каждой его итерации
}      
// Данный цикл можно сделать бесконечным если прописать i < 0, нужно быть с эти осторожным

// Иногда возникает необходимость закончить цикл досрочно, напрмер если i примет какое-то
// специфическое значение
// для этого используется ключевое слово break
// Пример

let num6 = 100;

for (let i = 0; i < 8; i++) { 
	if (num6 === 106) {
		break;                //ключевое слово break полностью прервет цикл
	}
	console.log(num6);         
	num6++;                 
} 

// Иногда возникает необходимость пропустить шаг цикла, напрмер если i примет какое-то
// специфическое значение
// для этого используется ключевое слово continue
// Пример

let num7 = 2;

for (let i = 0; i < 12; i++) { 
	num7++;                      // если выражение поставть после conosle.log - continue
	if (num7 === 5) {            // сработает как break
		continue;                // ключевое слово continue пропустит шаг цикла кода num7 будет === 5
	}
	console.log(num7);           // выдаст 3, 4, (5 пропустит), 6, 7 и т.д. 
				  
} 

// Важно не путать циклы с методами перебора forEach, filter, map

// Практика №2

// Задание 

// 1) Автоматизировать вопросы пользователю про фильмы при помощи цикла

// 2) Сделать так, чтобы пользователь не мог оставить ответ в виде пустой строки,
// отменить ответ или ввести название фильма длинее, чем 5 символов. Если это происходит - 
// возвращаем пользователя к вопросам опять

// 3) При помощи условий проверить  personalMovieDB.count, и если он меньше 10 - вывести сообщение
// "Просмотрено довольно мало фильмов", если от 10 до 30 - "Вы классический зритель", а если больше - 
// "Вы киноман". А если не подошло ни к одному варианту - "Произошла ошибка"

// 4) Потренироваться и переписать цикл еще двумя способами*/

// Код возьмите из предыдущего домашнего задания

/* const numberOfFilms2 = +prompt("Сколько фильмов вы уже посмотрели?", "");

const personalMovieDB2 = {
	count: '',
	movies: {},
	actors: {},
	genres: [],
	privat: false
};

personalMovieDB2.count = numberOfFilms2;
// Выполним задание №3
if (personalMovieDB2.count < 10) {
	alert("Просмотрено довольно мало фильмов");
} else if (personalMovieDB2.count >= 10 && personalMovieDB2.count < 30) {
	alert("Вы классический зритель");
} else if (personalMovieDB2.count >= 30) {
	alert("Вы киноман");
} else {
	console.log("error");
}

// Выполним задание №1
for (let i = 0; i < 2; i++) {
	const lastFilms2 = prompt("Один из последних просмотренных фильмов?", ""),
		  rating2 = +prompt("На сколько оцените его?", "");
	//Выполним задание 2
	if (lastFilms2 == "" || rating2 =="" || lastFilms2 == null || rating2 == null || lastFilms2.length > 5) {
		i--;
	} else  {
		personalMovieDB2.movies[lastFilms2] = rating2; 
	}
 
}  */

// Выполним задание 4
// При помощи цикла while
/* let i = 0;
while (i < 2) {
	const lastFilms2 = prompt("Один из последних просмотренных фильмов?", ""),
	rating2 = +prompt("На сколько оцените его?");
	//Выполним задание 2
	if (lastFilms2 == "" || rating2 =="" || lastFilms2 == null || rating2 == null || lastFilms2.length > 5) {
	i--;
	} else  {
	personalMovieDB2.movies[lastFilms2] = rating2;
	i++; 
}
} */

// При помощи цикла do ... while
/*  let i = 0;
do {
	const lastFilms2 = prompt("Один из последних просмотренных фильмов?", ""),
	rating2 = +prompt("На сколько оцените его?");
	//Выполним задание 2
	if (lastFilms2 == "" || rating2 =="" || lastFilms2 == null || rating2 == null || lastFilms2.length > 5) {
	i--;
	} else  {
	personalMovieDB2.movies[lastFilms2] = rating2;
	i++;
	}
} while(i < 2); */

/* console.log(personalMovieDB2); // выведем все в консоль.  */


/// ФУНКЦИИ В JS

// Функции являются основными «строительными блоками» программы.
// Функции - это наши действия в JS, они используют различные типы даннных и изменяют программу
// так как мы ей укажем.
// Функции значительно сокращают наш код. Мы можем написать одну функцию, а зетем вызывать
// ее сколько угодно раз.

// Пример обычный калькулятор это просто набор математических функций.

// Синтаксис Функции:
// Сначала прописываем ключевое слово function
// Прописываем или не прописываем имя функции (функция без имени - это анонимная функция)
// Ставим круглые скобки, в них мы передаем аргументы функции
// Ставим фигурные скобки, в них мы пропишем действия функции 
// Вызываем функцию обращаясь к ее имени и ставя круглые скобки showFirstMassege();
// Если мы передаем аргумент на вход функции например (text), сам текст мы указываем при
// вызове данной функции showFirstMassege("Hello everyone");

//Пример

function showFirstMassege (text) {
 console.log(text);
}

showFirstMassege("Hello everyone"); // при вызове функции она берет текст Hello everyone
// далее передает его аргументом (text) на вход функции, а функция совершает действие с аргументом
// в данном случае выводит в консоль текст Hello everyone за счет команды console.log
// Анонимная функция вызывается и используется прямо сдесь и сейчас только 1 раз
// ВАЖНО!! Имя функции должно быть глаголом с препиской того, над чем выполняется ее действие
// Аргументы функции - это данные на вход, функция будет использовать их внутри себя
// Аргументов, которые функция принимает на вход может быть множество, 
// они указываются через зяпятую (text, num, a, b)
// Как пример в куалькулятор мы передаем 2 числа 4 и 5 функция сложения будет их складывать

// Eще один пример функции - сложения 2-ух чисел
const a = 4;
const b = 5;

function addition (result) {
	console.log(result);       // выведет в консоль результат сложения чисел 5 и 4
   }

addition(a + b);

// Как ведут себя переменные внутри функции (объявленные внтури фигурных скобок)?
// Все, что прописано в фигурных скобках это локальная область видимости 
// и мы НЕ можем обращаться из глобальной области видимости (все что снаружи фигурных скобок)
// в локальную область (например к переменным) они будут просто не доступны. 
// Из глобальной области видимости не видно то, что лежит в локальной области.
// Пример:
function showMustGo() {
	let num = 5;
}

showMustGo();

console.log(num); // выдаст ошибку num is not defined, потому как мы не можем достучаться 
// из глобальной области до перменной num, которая существует локально внутри функции. 

// НО! из локальной области видимости функции мы спокойно можем обращатся к тому, что лежит
// в глобальной области видимости.
// Т.е. любая функция может брать и использовать внутри себя переменные, которые объявлены глобально.

// Пример
let num8 = 10;

function showNum() {
	num8 = 5;        // в теле функции возьмем глобальную переменную num8 перезапишем ее значние на 5
}
showNum();
console.log(num8);  // а затем выведем значение перменной num8 в консоль.

// Переменные с одинаковым именем созданные в глобальной и локальной области это
// разные переменные

let num9 = 10;             // переменная num9 объявлена глобално и видна во всем коде

function showNum() {
	let num9 = 15;         // переменная num9 объявлена и видна локально только в теле функции
	console.log(num9);     // на выходе будет 15, т.е. выведет значение локальной перменной
}
showNum();

console.log(num9);  // на выходе будет 10, т.е. выведет значение глобальной перменной
// ВАЖНО!!! Частый вопрос на собеседованиях!
// Замыкание функции - это сама функция вместе со всеми внешними пременными, 
// которые ей доступны. Причем функция берет в работу только последнее изменение 
// внешней переменной.

// Пошаговый путь работы функции:
// Функция showNum() после ее вызова, сначала передает аргумент на вход функции, если он есть
// Далее функция showNum1() ищет значение переменной num10 в локальной области
// В случае, если она не находит эту переменную в локальной области,
// она обращается в глобальную. 
// Т.е. команда console.log(num10) выведет значение глобальной переменной num10 = 11

let num10 = 11;                

function showNum1() {
	console.log(num10);        
}
showNum1();

// Функции могут возвращать нам значения при помощи ключевого слова return
// Как только функция увидит return она прекратит свое действие

function calc (a, b) {   // функция calc() принимает на вход 2 аргумента a и b
	return (a + b);	     // при помощи ключевого слова return функция calc()
}                        // возвращает результат сложения аргументов a и b
//возвращаемое значение возвращается к вызывающей области т.е. в calc(результат сложения)

console.log(calc(3, 6)); // каждый раз при вызве функции calc() мы передаем в нее аргументы
console.log(calc(5, 8)); // и она возвращает нам резульат их сложения
console.log(calc(1, 1));

// Код, который идет после ключевого слова retrun назвается мертвым Unreachable - он не работает
// и некогда не выполнится.

// Return возвращает значения из функции в глобальную область видимости
// Пример
function ret() {   // объявим функцию ret()
	const g = 50;  // зададим определение функции ret и объявим в ней переменную g = 50
	return g;      // функция ret() возвращает нам значение переменной g при ее вызове
}                  // в глобальную область видимости

const g2 = ret(); // объявим переменную g2 и присвоим ей вызов функции ret()
// после чего перменной g2 будет присвоено возвращаемое функцией ret() значение = 50
console.log(g2);  // на выходе будет 50

//Классификация функций в JS

//1) Function declaration
// Создается до начала выполнения скрипта, данную функцию можно вызывать перед объявлением
// Пример
console.log(foo(5, 6)); // т.е. мы вызваем функцию раньше, чем мы ее объявили

function foo(a, b) {
	return (a + b);
}

//2) Function expression
// Создается только тогда, когда до нее доходит поток кода, 
// данную функцию можно вызывать ТОЛЬКО после объявления переменной, которой она присвоена.
// Если вызвать функцию до объявления перменной, которой она присвоена получим ошибку
// переменная is not defined
// Пример

const foo2 = function (a, b) {
	return (a + b);
};

console.log(foo2(5, 6));

//3) Стрелочные функции (добавлены в стандарте ES6)
// Синтаксис
// Создаем переменную например c именем calc3
// Присваиваем ей следующую конструкцию (a, b) => {a + b};
// В круглые скобки записываются аргументы принимаемые функцией calc3 на вход
// После знака => в фигурных скобках {} прописывается определение функции, 
// т.е. то, что она будет делать
// Стрелочная функция не имеет контекста this
const calc3 = (a, b) => {
	console.log("1");
	return a + b;
};

// В случае, если исполняемый функцией код можно прописать в одну строку, 
// то фигурные скобки можно не использовать
// Пример

const calc4 = (a, b) => a + b;

// В случае если функция имеет 1 аргумент, то круглые скобки тоже можно не использовать
// Пример
const calc5 = a => a;


/// МЕТОДЫ И СВОЙСТВА У СТРОК И ЧИСЕЛ

// Методы - это вспомогательные функции.
// Методы являются вспмогательными функциями и они вызываются используя ()

// Свойства - это вспомогательные значения. 
// Свойства никак не вызываются. Их прописывают после точки.

// Все названия методов и свойств можно найти в офф. документации.
// Кроме офф. документации можно воспользоваться браузером и получить их в консоли
// воспользовавшись командой console.dir
// Напрмер console.dir(Number)
// Открыть полученный глобальный объект и посмотреть методы и свойства примитива Number

// Свойство length позволяет позволяет посчитать длинну строки

const str = "test";      // объявим переменную str и присвоим ей строку test

console.log(str.length); // посчитаем кол-во символов в строке test при помощи свойства length
// на выходе будет 4

// Определенный символ из строки можно получить обратившись к его порядковому индексу

const str2 = "test2"; // объявим переменную str2 и присвоим ей строку

console.log(str2[2]); // обратимся к индексу 2 строки и на выходе получим букву s,
// которая соответсвует порядковому индексу 2 строки test2. Нумерация начинается с 0.

// В отличии от массива мы не можем заменить букву в строке обратившись к ее индексу
// Пример
/* const str3 = "test3"; //объявим переменную str3 и присвоим ей строку

str3[2] = "b"; // обратимся к индексу 2 строки и попытаемся поменять букву s на b

console.log(str3); // замена буквы s на b не сработает, на выходе также будет test3 */


// Свойство length так же позволяет посчитать кол-во элементов внутри массива

const arr8 = [12, 10, {}, [], "test"]; // объявим переменную arr8 и присвоим ей массив

console.log(arr8.length); //посчитаем кол-во элементов в массиве при помощи свойства length
// на выходе бует 5

// Свойство length позволяет за счет выражения length - 1 вернуть
// индекс последнего элемента массива

const arr9 = [12, 10, {}, [], "test"]; // объявим переменную arr9 и присвоим ей массив

console.log(arr9.length - 1); // вернет порядковый индекс последнего элмента массива arr9 = 4

// Метод изменения регистра строки to toUpperCase на заглавные буквы

const str10 = "Test"; // объявим переменную str10 и присвоим ей строку

console.log(str10.toUpperCase()); // обратившись к строке str10, и вызвав метод toUpperCase()
// на выходе получим строку TEST (т.е. в верхнем регистре)

console.log(str10.toLowerCase()); // обратившись к строке str10, и вызвав метод toLowerCase()
// на выходе получим строку test (т.е. в нижнем регистре)

console.log(str10);// Метод не изменяет значение той строки, к которй он применяется. 
//Метод возвращает новое значение, которые мы можем, к примеру, записать в другую переменную
// и использовать где-то дальше.

// Метод indexOf() (поиск подстроки) возвращает первый индекс, 
// по которому данный элемент может быть найден в массиве или -1, если такого индекса нет.
// Если проще, то метод позволяет найти кусок строки и сказать с какого индекса он начинается.

const str11 = "Some everything"; // объявим переменную str11  и присвоим ей строку

console.log(str11.indexOf('everything')); // выведет 5, потому как индекс строки
// с которого начинвается слово everything = 5. Нумерация начинается с 0.

// Данный метод чаще применяется для поиска в тексте опеределенного слова или значения.
//Пример
const str12 = "Some everything"; // объявим переменную str11  и присвоим ей строку

console.log(str12.indexOf('q')); // аругументом метода ndexOf передадим 'q', на выходе будет -1, 
//что значит, что искомой буквы q в тексте нет

// Изменения строк при помощи методов для этого существует 3 способа

// 1) Метод slice() принимает на вход 2 аргумента
// 1 аргумент start указывает на индекс символа строки, с которого мы начнем вырезать ее кусок.
// 2 аргумент end указывает на индекс символа строки на котором мы закончим вырезать ее кусок,
// НО уже НЕ ВКЛЮЧАЯ последний символ

const str4 = "qwerty 123 zxcvby";

console.log(str4.slice(11, 16)); // на выходе будет строка 'zxcvb' символ 'y' не будет учтен

// В случе, если нужно обрезать кусок начиная с какого-то индекса, а дальше не резать, т.е.
// вернуть всю остальную часть строки, 
// то мы указываем только 1 аргумент метода slice() - индекс с которого начинать.

const str5 = "qwerty 123 zxcvbytttttttttttt";

console.log(str5.slice(11)); // на выходе будет zxcvbytttttttttttt

// Метод slice поддерживает и отрицательные значения аргументов, тогда резка начинается с конца строки

const str6 = "yyyTTT";

console.log(str6.slice(-3)); // т.е. нумерация начинается слева направо, на выходе будет TTT

// Метод slice больше применим к массивам, для строк лучше использовать метод subString()
const arr6 = [1, 2, 5, 8, 11, 44];

console.log(arr6.slice(1, 4)); // на выходе вернет массив [ 2, 5, 8 ]

// 2) Метод substring()
// 1 аргумент start указывает на индекс символа строки с которого мы начнем вырезать ее кусок
// 2 аргумент end указывает на индекс символа строки на котором мы закончим вырезать ее кусок,
// НО уже НЕ ВКЛЮЧАЯ последний символ 
// Метод subString() НЕ поддерживает и отрицательные значения аргументов

const str7 = "qwerty 123 zxcvbytttttttttttt";

console.log(str7.substring(11)); // на выходе будет zxcvbytttttttttttt

// 3) Метод substr()
// 1 аргумент start указывает на индекс символа строки с которого мы начнем вырезать ее кусок
// 2 аргумент указывает какое кол-во символов строки мы вырезаем ПОСЛЕ индекса start 
// Т.е. данный метод указывает сколько символов нужно вырезать из строки, и на то с какого по порядку начать 
const str13 = "qwerty 123 zxcvbytttttttttttt";

console.log(str13.substr(2, 7)); // на выходе будет erty 12

// Методы чисел

// Для работы с числами в JS существет мини библиотека Math, которая существет внутри браузеров
// Для того чтобы посмотреть что в ней есть, можно к консоли с большой буквы прописать Math. (с точкой)

// Метод для округления чисел до ближайшего целого round()

const numOne = 3.5;

Math.round(numOne);

console.log(Math.round(numOne));

// Еще один метод для преобразования строк в числа - parseInt(). Работает даже если в строке есть буквы
// Метод parseInt() превращает число в другую систему изчисления. 
// Метод parseInt() обрезает дробные числа с типом данных строка до целого и возращает нам тип данных число
// ВАЖНО!!! не округляет, а именно обрезает текущее значение до целого  и возвращает. 
const Str = "12.5px"; //напрмер мы получили размеры определенного элемента и присвоили их переменнной Str

console.log(parseInt(Str)); // вернет нам 12. Метод парсит(вычленяет и строк числа и возвращает их)

//Метод parseFloat() возвращает нам числа из строк, 
// но в отличии от parseInt может вернуть нам их в десятичном варианте (с плавающей точкой). 

const Str1 = "12.5px"; //напрмер мы получили размеры определенного элемента и присовили их переменнной Str

console.log(parseFloat(Str1));

// Метод isNaN() проверяет свой аргумент и если он не число, возвращает нам true (правду)
// Пример 

const Str3 = "srtiiing";

console.log(isNaN(Str3)); // т.к. значение переменной Str3 не число, метод возвращает нам true(правду)

/// ПРАКТИКА №3.

/* Задание на урок:

1) Первую часть задания повторить по уроку

2) Создать функцию showMyDB, которая будет проверять свойство privat. Если стоит в позиции
false - выводит в консоль главный объект программы

3) Создать функцию writeYourGenres в которой пользователь будет 3 раза отвечать на вопрос 
"Ваш любимый жанр под номером ${номер по порядку}". Каждый ответ записывается в массив данных
genres

P.S. Функции вызывать не обязательно*/

// Код возьмите из предыдущего домашнего задания

// Выполним задание №1

// Переведем наше web-приложение в функциональный вид.
/* let numberOfFilms3;

function start() {
	numberOfFilms3 = +prompt("Сколько фильмов вы уже посмотрели?", "");

	while(numberOfFilms3 == "" || isNaN(numberOfFilms3 ) || numberOfFilms3 == null) {
		numberOfFilms3 = +prompt("Сколько фильмов вы уже посмотрели?", "");
	}
}

start(); */

/* const personalMovieDB3 = {
	count: numberOfFilms3,
	movies: {},
	actors: {},
	genres: [],
	privat: false
}; */

/* function detectPersonalLevel() {
	if (personalMovieDB3.count < 10) {
		alert("Просмотрено довольно мало фильмов");
	} else if (personalMovieDB3.count >= 10 && personalMovieDB3.count < 30) {
		alert("Вы классический зритель");
	} else if (personalMovieDB3.count >= 30) {
		alert("Вы киноман");
	} else {
		console.log("error");
	}
}

detectPersonalLevel(); */
// Выполним задание 3 первым способом
/* function writeYourGenres() {
	for (let i = 1; i <=3; i++) {  
		personalMovieDB3.genres[i-1] = prompt(`Ваш любимый жанр под номером ${i}`);       
		                
	}      
}
writeYourGenres(); */

// Выполним задание 3 вторым способом добавив внего проверку полученных от пользователя данных

/* function writeYourGenres() {
	for (let i = 1; i <=3; i++) {
		const genre = prompt(`Ваш любимый жанр под номером ${i}`);
		if (genre == "" || genre == null) {
			i--;
		}else {
			personalMovieDB3.genres[i-1] = genre;
		}
	}
}

writeYourGenres(); */

/* function rememberOfFilms() {
	for (let i = 0; i < 2; i++) {
		const lastFilms3 = prompt("Один из последних просмотренных фильмов?", ""),
			  rating3 = +prompt("На сколько оцените его?", "");
		//Выполним задание 2
		if (lastFilms3 == "" || rating3 =="" || lastFilms3 == null || rating3 == null || lastFilms3.length > 5) {
			i--;
		} else  {
			personalMovieDB3.movies[lastFilms3] = rating3; 
		}
	 
	} 
}

rememberOfFilms(); */
// Выполним задание 2 первым способом
/* function showMyDB() {
	if (personalMovieDB3.privat == false) {
		console.log(personalMovieDB3);
	}
}

showMyDB(); */

//Выполним задание 2 вторым способом - передав аргумент personalMovieDB3.privat в функцию showMyDB()

/* function showMyDB(hidden)  {
	if (!hidden) {                     // оператор отрицания ! поменяет false на true
		console.log(personalMovieDB3); // и в консоль выведет объект personalMovieDB3 
	}
}
showMyDB(personalMovieDB3.privat); */



/// Callback ФУНКЦИИ В JS

// Callback функция - это функция, которая должна быть выполнена после того, 
// как другая функция завершила выполнение (отсюда и название: callback – функция обратного вызова).
// Любая функция, которая передается как аргумент в другую функцию, называется callback-функцией.

function first() {           // создадим функцию которая с задержкой в пол секунды выведет 1 в консоль
	// Do something
	setTimeout(function() {
		console.log(1);
	}, 500);
	console.log(1);         // выдаст в консоль сообщение 1 с задеркой пол секунды во вторую очередь
}

function second() {
	console.log(2);         // выдаст в консоль сообщение 2 в первую очередь
}

first(); 
second();

// Важно!!! Если функции в коде идут одна за другой, это не значит что они и выполняются в таком порядке

// Пример callback функции
// Cоздадим функцию learnJS() 
function learnJS (leng, funcCallback) { // и вторым аргументом передадим в нее callback функцию funcCallback()
	console.log(`Я учу: ${leng}`);
	funcCallback();                     // вызываем callback функцию funcCallback()
}

function done () {                     // создадим эту callback функцию и дадим ей имя done
	console.log("я прошел этот урок"); 
}

learnJS("Java Script", done);         // при вызове функции learnJS() вторым аргументом
// передадим в нее callback функцию done.
// ОЧЕНЬ ВАЖНО!!! Функцию done мы передаем как второй аргумент функции learnJS() 
// и поэтому скобочки ей уже не нужны!!!

// Пример использования callback функций в web разработке - сделать какое-то действие, ТОЛЬКО после
// того, как пользовать кликнул например по кнопке.
// Использование callback функций дает нам гарантию того, что один код не начнент своё исполнение,
// пока другой код не завершит свое исполнение. 



/// ОБЪЕКТЫ И ДИСТРУКТУРИЗАЦИЯ ОБЪЕКТОВ В JS (ES6). МЕТОДЫ ОБЪЕКТОВ.

// Объекты в JS это ассоциативные массивы.
// Ассоциативный массив — абстрактный тип данных (интерфейс к хранилищу данных), 
// позволяющий хранить пары вида «(ключ, значение)» 
// и поддерживающий операции добавления пары, а также поиска и удаления пары по ключу.

//const obj10 = new Object(); // Создадим объект через команду new Object()
// Данным способом почти никогда не пользуются, но так можно их создавать.

//Создадим новый объект newOptions
const newOptions = {
	name: "test",
	whidth: 1024,
	height: 1080,
	colors: {
		border: "black",
		background: "red"
	}

};

console.log(newOptions.colors.border); // выведем в консоль значение свойства вложенного объекта

// В случае если нам нужно удалить какую-то свойство из объекта, то можно воспользоваться оператором
// delete 
// Ситаксис следующий:
// Мы прописываем оператор delete и через пробел прописываем имя объекта и через точку свойство, которое
// необходимо удалить из этого объекта

delete newOptions.name;  // в данном случае оператор delete удалит свойство name объекта newOptions

console.log(newOptions); 

// В случае если нам необходимо удалить множество свойств объекта, мы можем воспользоваться циклом.

// Для перебора всех свойств объекта мы должны использвать Цикл for…in
// У данного цикла будет столько итераций сколько свойств внутри данного объекта

const newOptions2 = {
	name1: "test",
	whidth: 1024,
	height: 1080,
	colors: {
		border: "black",
		background: "red"
	}
};

for (let key in newOptions2) {
	console.log(`Свойство ${key}, имеет значение ${newOptions2[key]}`);
}

// Свойство colors при выводе в консоль, имеет значение [object Object], т.к. в консоль на выводит
// строковый тип данных и Js не может превратить в строку вложенный объект. 
// JS всеместо самого вложенного объекта, выводит строковое представление объекта [object Object].

// Для того, чтобы все таки вывести в консоль значение вложенного объекта запустим перебор в переборе
// воспользовавшись циклом цикл for…in 2 раза.
const newOptions3 = {
	name1: "test",
	whidth: 1024,
	height: 1080,
	colors: {
		border: "black",
		background: "red"
	}
};

for (let key in newOptions3) {
	if (typeof(newOptions3[key]) === "object") { // если значение свойства вложеннный объект
			for (let i in newOptions3[key]) {    // запускаем перебор свойств этого объекта
				console.log(`Свойство ${i}, имеет значение ${newOptions3[key][i]}`); // выводим их в консоль
			}
	} else { // иначе просто выводим в консоль значения свойств объекта
		console.log(`Свойство ${key}, имеет значение ${newOptions3[key]}`); 
	} 
	
}

// Функции и методы, которые уже есть внутри объекта

// Создадим счетчик для подсчета кол-ва свойств объекта используя предыдущий код
const newOptions4 = {
	name1: "test",
	whidth: 1024,
	height: 1080,
	colors: {
		border: "black",
		background: "red"
	}
};

let counter = 0; // объявим переменную счетчика counter и присвоем ей значенеие 0

for (let key in newOptions4) {
	if (typeof(newOptions4[key]) === "object") {
		for (let i in newOptions4[key]) {
			console.log(`Свойство ${i}, имеет значение ${newOptions4[key][i]}`);
			counter++; // т.к. идет развилка по условию и в данный цикл добавим инкремент счетчика counter                               			
		}
	} else {
		console.log(`Свойство ${key}, имеет значение ${newOptions4[key]}`);
		counter++; //добавим инкрмент счетчика counter для подсчета кол-ва итераций цикла подсчета свойств
	}
}

console.log(`Киличество свойств в объекте newOptions4 равно ${counter}`); //выведем в консоль кол-во свойств

// Методы объекта

// Метод объекта Object.keys берет аргументом объект и на его основе возвращает массив, 
// элементы которого - это ключи данного объекта первого уровня.

const newOptions8 = {
	name1: "test",
	whidth: 1024,
	height: 1080,
	colors: {
		border: "black",
		background: "red"
	}
};

console.log(Object.keys(newOptions8)); // на выходе будет [ 'name1', 'whidth', 'height', 'colors' ]

// У массива есть свойство length, которое считает длинну массива, т.е. выводит кол-во его элементов.
// Мы можем воспользваться методом Object.keys, которе вернет нам массив со свойствами объекта,
// а после посчитать кол-во его свойств записанных в массив при помощи свойства массива length.
const cuunter2 = Object.keys(newOptions8);
console.log(cuunter2.length);
// Либо сразу вывести в консоль кол-во элентов массива полученного от Object.keys
// и которое = кол-ву свойств объекта newOptions5 
console.log(Object.keys(newOptions8).length);


// Создание методов объектов вручную

// Методы это дейтсвия, которые умеет совершать объект

// Создадим новый объект newOptions6

const newOptions6 = {
	name1: "test",
	whidth: 1024,
	height: 1080,
	colors: {
		border: "black",
		background: "red"
	},
	// пропишем ключ объекта newOptions6 как метод с именем makeTest, а значением  будет безымянная функция
	makeTest: function() { 
		console.log('Test'); // которая выведет в консоль строку test
	}
	
};

newOptions6.makeTest(); //обратимся к newOptions6 и вызовем объект makeTest()

// Деструктуризация объектов в JS(ES6)

// Порой нам необходимо получить доступ к вложенным свойтсвам объекта
// Создадим новый объект newOptions7
const newOptions7 = {
	name1: "test",
	whidth: 1024,
	height: 1080,
	colors: {
		border: "black",
		background: "red"
	},
	// пропишем ключ объекта newOptions6 с именем makeTest, а значением  будет безымянная функция
	makeTest: function() { 
		console.log('Test'); // которая выведет в консоль строку test, это и будет метод объекта
	}
	
};
// Деструктуризируем объект newOptions7
// 1) Вытащим ключи вложенного объекта в качестве отдельных структур (Вынесем их за наш объект newOptions7 )
// пропишем ключевое слово const и поместим во внутрь фигурных скобок ключи вложенного объекта.
// 2) Присваиваем данным ключам свойство, значением которого является объект с вложенными ключами
const {border, background} = newOptions7.colors;

console.log(border); // после деструктуризации объекта newOptions7 выведем значение свойства border


/// МЕТОДЫ МАССИВОВ. ПСЕВДОМАССИВЫ

// Массив - это структура для хранения данных, которые идут СТРОГО!!! по по порядку.

// Самые часто используемые методы массивов.

// Метод pop() - удаляет последний элемент из массива
const arr2 = [1, 2, 6, 7, 8, 11, 55];

arr2.pop();

console.log(arr2); // на выходе [ 1, 2, 6, 7, 8, 11 ]

// Метод push() - добавляет элемент в конец массива. 
// Принимает аргументом значение элемента, который нужно добавить в конец массива.
const arr3 = [1, 2, 6, 7, 8, 11, 55];

arr3.push(88);

console.log(arr3); // на выходе [1, 2, 6, 7, 8, 11, 55, 88]

// Для добавления элемента в начало массива существует метод shift()

// Для удаления элемента из начала массива сущемствует метод unshift()

// Данные методы очень редко используют, т.к. у методов shift() и unshift() есть очень большой недостаток -
// после вставки или удаления из/в начало массива, нам будет необходимо поменять индкусы у последующих
// элементов данного массива.

// Для перебора элементов массива мы можем использовать как цикл for
// И чтобы задать кол-во итераций цикла for, воспользуемся свойством lenght
// Пример

const arr7 = [1, 2, 6, 7, 8, 11, 55];

for(let i = 0; i < arr7.length; i++) {
	console.log(arr7[i]); // используем именно квадратные скобки [], а не круглые(), т.к. мы обращаемся 
	// к элементу массива 
}
// ВАЖНО!!! Вопрос на собеседовании: как соотноститтся между собой свойство length 
// и порядковые индексы массива. Свойство length - это последний индекс масссива + 1.

// Иногда данное правило может нарушиться
// Пример
const arr10 = [1, 2, 6, 7, 8, 11, 55];

arr10[99] = 10;

console.log(arr10.length); // Выдаст длинну массива = 100, хотя всего 8 элементов
console.log(arr10); // [ 1, 2, 6, 7, 8, 11, 55, <92 empty items>, 10 ] т.е после 55 идут 92 пустые ячейки

// Отсюда мы можем узнать порядковый индекс последнего элемента массива length - 1.
// Так же можно использовать метод перебора элеметов массива for..of.
// Цикл for..of работает только с массиво-подобными сущностями (массивы, строки, псевдомасиивы, 
// cущности map и set, или элементы со страницы), он не работает с объектами. 

const arr4 = [1, 2, 6, 7, 8, 11, 55];

for(let value of arr4) {
	console.log(value);
}

// Метод forEach - самый часто используемый метод для массивов. Данный метод позволяет гибко перебрать 
// все элементы массива. Но его можно получше настроить. 
// Данный метод аргументом принимает в себя callback функцию.
// Данная callback функция применяется на каждой итерации метода forEach на каждом элементе данного массива.   
// Синтаксис
// 1) Обращаемся к инетересующему массиву и прописываем метод forEach()
// 2) Аргументом передаем callback функцию function() {
// данная функция будет выполняться на кажой итерации метода, для каждого элемента массива}
// 3) callback функция в себя может принимать 3 аргумента:
// 1-ый аргумент - это тот элемент, который мы сейчас перебираем. Называем его как угодно - например item.
// 2-ой аргумент - это номер по порядку i. 
// 3-ий аргумент это ссылка на тот массив, который мы в данный момнт перебираем arr5

const arr5 = [1, 2, 6, 7, 8, 11, 55];

arr5.forEach(function(item, i, arr5) {
	console.log(`Номер ${i} массива ${arr5} это ${item}`);
}); 

//Данную код можно прописать в виде стрелочной функции
arr5.forEach((item, i, arr5) => {
	console.log(`Номер ${i} массива ${arr5} это ${item}`);
});

////////////////////////////////////////////////////////
// ВАЖНО!!!
// Цикл обычного перебора массива for..of используют когда нужно использовать break и continue
// для того чтобы оставновить цикл break или пропустить его шаг continue

// Метод перебора массивов forEach используют во всех остальных случаях. Метод forEach нульзя остановть 
// при помощи break или пропусть шаг при помощи continue.
/////////////////////////////////////////////////////////

// Перебирающие методы трансформирующие массив:

// Метод map() создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.

// Метод every() проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции.
// метод возвращает true при любом условии для пустого массива.

// Метод some() проверяет, удовлетворяет ли какой-либо элемент массива условию, заданному в передаваемой функции.
// метод возвращает false при любом условии для пустого массива.

// Метод filter() создаёт новый массив со всеми элементами, 
// прошедшими проверку, задаваемую в передаваемой функции.

// Метод reduce() применяет функцию reducer к каждому элементу массива (слева-направо), 
// возвращая одно результирующее значение.

// Данные методы мы изучим позже. 


// Метод split() осуществляет разбиение строки в массив по указанному разделителю.
// Разделитель указывается первым необязательным аргументом. 
// Если он не задан - вернется вся строка. 
// Если он задан как пустые кавычки '' - то каждый символ строки попадет в отдельный элемент массива.
// Вторым необязательным аргументом можно указать максимальное количество элементов 
// в получившемся массиве.

const str33 = "111; 222; 333; 444; 555";

const products = str33.split("; ");

console.log(products); //  на выходе получим массив [ '111', '222', '333', '444', '555' ]. 
// У элементов будет тип данных строка.
// Каждый символ строки попадет в отдельный элемент массива.

// Тоже самое но передадим 2-ой аргумент в метод split() как ограничитель вывода элементов массива
const str38 = "111; 222; 333; 444; 555";

const products1 = str38.split("; ", 2);

console.log(products1); // на выходе будет массив [ '111', '222' ], 
// т.е. срабоатл ограничитель вывода в 2 элемента.


// Обратный метод для метода split() - метод join
// Метод join преобразующий массив в строку и разделяющий элементы выбранным разделителем, например запятой.

const arr33 = ["Иван", "Алесандр", "Юлия", "Максим", "Алексей", "Петр", "Сергей"];

console.log(`Список приглашеннх игроков: ${arr33.join(", ")}`); // на выходе будет строка - 
// Список приглашеннх игроков: Иван, Алесандр, Юлия, Максим, Алексей, Петр, Сергей

// Метод сортировки sort() - на месте сортирует элементы массива и возвращает отсортированный массив.
// Данный метод всегда сортирует элементы массива как строки в алфавитном порядке.
const arr34 = ["Иван", "Алесандр", "Юлия", "Максим", "Алексей", "Петр", "Сергей"];

console.log(arr34.sort());
// на выходе будет ['Алексей', 'Алесандр', 'Иван', 'Максим', 'Петр', 'Сергей', 'Юлия']

// Массивы содержащие числа он сортирует по первой цифре числа 
const arr35 = [1, 20, 10, 99, 324, 11, 1024];

console.log(arr35.sort());
// на выходе будет [1, 10, 1024, 11, 20, 324, 99] т.е. сортировка по первой цифре числа, далее посимвльно

// Метод sort() аргументом может принимать callback функцию,
// в которой мы можем сказать как именно сортировать данный массив.
const arr36 = [1, 20, 10, 99, 324, 11, 1024];

console.log(arr36.sort(compareNum)); // не вызывая передаем в callback функцию compareNum
// аргументом в метод sort(). На выходе будет массив [1, 10, 11, 20, 99, 324, 1024] 
// элементы которого (числа) отсортированы по возрастанию. 

//Создадим шаблон сортировчной callback функции 
// на вход функции передадим 2 аргумента - 1ое a число и 2-ое число b которые сравниваются
function compareNum(a, b) { 
	return a - b;            //функция будет возвращать результат разности a - b
}

// Метод sort() содержит в себе алгоритм быстрой сортировки

// ПСЕВДОМАССИВЫ
// Псевдомассив — это объект, который структурно похож на массив. 
// Т.е. у него есть числовые свойства (индексы) и свойство length.
// НО у псевдомассивов не будет никаких методов. 
// Работая с элементами на странице мы будем получать именно псевдомассивы (html коллекции).



/// ПЕРЕДАЧА ДАННЫХ ПО ССЫЛКЕ ИЛИ ПО ЗНАЧЕНИЮ, Spread оператор. !!!ОСОБОЕ ВНИМАНИЕ К ДАННОЙ ТЕМЕ!!!

let ggg = 5,  // объявляем переменную ggg и присваиваем ей значение 5
	bbb = ggg; // объявляем переменную bbb и присваиваем ей как значение перменную ggg

bbb = bbb + 10; 
console.log(bbb); // на выходе будет 15
console.log(ggg); // на выходе будет 5, т.е. переменная ggg не меняется

const obj4 = {  // создадим переменную obj и прсивоим ей значение объекта 
	a: 2,
	b: 4,
	c: 7
};

const copy = obj4; // создадим переменную copy и присвоим ей как значение пепеменную obj4 

copy.a = 24;

console.log(copy); //на выходе будет объект { a: 24, b: 4, c: 7 }
console.log(obj4); //на выходе будет объект { a: 24, b: 4, c: 7 }, 
// хотя мы модифицировали копию объекта obj4, а не сам объект obj4 

// Кода мы работаем с примитивами типа строк, чисел, логических значений, то они передаются по ЗНАЧЕНИЮ!

// Когда мы работаем с объектами (массивами, функциями, объектами даты), то они передаются по ссылке.
// Т.е. в переменная copy1 не была скопирована при const copy1 = obj5;, а ей присвоилась ссылка 
// на объект obj5. 
const obj5 = {  // создадим переменную obj и прсивоим ей значение объекта 
	a: 2,
	b: 4,
	c: 7
};

const copy1 = obj5; // в copy1 идет передача ссылка на объект obj5
// Т.Е. ПРИ МОДИФИКАЦИИ ССЫЛКИ НА ИЗНАЧАЛЬНЫЙ ОБЪЕКТ МЫ МОДИФИЦИРУЕМ САМ ЭТОТ ОБЪЕКТ.
// Такое поведение называется передача по ссылке. 

// Способы создания поверхностных и глубоких копий объектов, массивов.

// Способ №1 - создаем поверхностную копию объекта при помощи цикла for...in
const obj7 = {  // создадим переменную obj7 и прсивоим ей значение объекта 
	a: 2,
	b: 4,
	c: 7
};
// Создадим функцию которая при помощи цикла for..in
// перебирая свойства изначального объекта создаст его поверхностную копию копию.
function copy2 (mainObj) { // функция mainObj принимает аргументом тот объект, который мы хотим скопировать
	let copyMainObj = {};  // создадим переменную copyMainObj в которую положим пустой объект
	for(let key in mainObj) {
		copyMainObj[key] = mainObj[key];
	}
	return(copyMainObj);
}

const coppYY = copy2(obj7);

console.log(coppYY); //Выдаст копию coppYY объекта obj7 

// Для того чтобы в этом убедиться присвоим свойству a основоного объекта obj7 значение 9
// после чего выведем объект obj7 и его копию coppYY в консоль.

obj7.a = 225;

console.log(obj7); // на выходе будет объект { a: 225, b: 4, c: 7 } с изменненным свойством a = 225
console.log(coppYY); // на выходе будет объект { a: 2, b: 4, c: 7 } с изначальным значением a = 2

// При поверхностном копировании объектов происходит независимое копирование только
// свойств первого уровня. Все вложенные структуры при их изменении передаются по ссылке, т.е. меняют 
// основной объект. 
// Пример

const obj9 = {  // создадим переменную obj7 и прсивоим ей значение объекта 
	a: 2,
	b: 4,
	c: 7,
	d: {
		e: 77,
		j: 100
	}
};
// Создадим функцию которая при помощи цикла for..in
// перебирая свойства изначального объекта цикл создаст его поверхностную копию копию.
function copy2 (mainObj) { // функция mainObj принимает аргументом тот объект, который мы хотим скопировать
	let copyMainObj = {};  // создадим переменную copyMainObj в которую положим пустой объект
	for(let key in mainObj) {
		copyMainObj[key] = mainObj[key];
	}
	return(copyMainObj);
}

const coppYY1 = copy2(obj9);

obj9.a = 225;

// Для того, чтоьы убедиться, что при поверхностном копировании объектов вложенные структуры не копируются, 
// а передаются по ссылке, обратимся ко вложенном свойству объекта obj9.d и изменим его значение.

obj9.d.e = 555;

// После чего выведем оба объекта в консоль
console.log(obj9); // на выходе будет объект { a: 225, b: 4, c: 7, d: { e: 555, j: 100 } }
console.log(coppYY1); // на выходе будет объект { a: 2, b: 4, c: 7, d: { e: 555, j: 100 } }
// в обоих объектах вложенные свойства e: 555, т.е. свойства первого уровня независимо скопировались, 
// а вложенные свойтсва передались по ссылке и поменялись в обоих объектах. 

// Глубокие копии объектов мы будем создавать дальше по курсу. 

// Способ №2 копирования объектов - использование метода object.assign()
// Метод  object.assign()используется для копирования значений всех собственных перечисляемых свойств 
// из одного или более исходных объектов в целевой объект. 
// После копирования метод object.assign() возвращает целевой объект.

// Создадим 2 объекта add и add2

const add = {
	a: 44,
	b: 55
};

const add2 = {
	c: 77,
	d: 88
};

// Используя метод object.assign() соединим эти 2 объекта вместе.
// Важно!!! чтобы при соединении объектов при помощи метода assign() имена свойств этих обхектов
// не были одинаковыми  иначе произойдет их замена.  

const add3 = Object.assign(add, add2); // на выходе будет объект содержащий своства из объектов add, add2.

// Но если к примеру при помощи метода Object.assign попробовать соединить пустой объект 
// с тем объектом, для которого мы хотим создать копию.

const add4 = {   // созадаим исходный объект add4 
	a: 444,
	b: 111
};

const add5 = Object.assign({}, add4); // первым аругментом метода Object.assign передадим пустой объект, 
// вторым аргументом тот объект для которого мы хотим созадать копию

add5.b = 888; // обратимся к копии объекта add5 и поменяем в нем значение свойства b
// Выведем певоначальный объект add4 и его копию add5 в консоль
console.log(add4); // на выходе будет объект { a: 444, b: 111 }
console.log(add5); // на выходе будет объект { a: 444, b: 888 }, т.е независимая поверхностная копия 

// Копирование массивов

// Для того, чтобы созадать поверхностную копию массива, мы можем точно так же написать функцию, 
// НО мы так же можем использовать метод slice()
// Метод slice() возвращает новый массив, содержащий копию части исходного массива.

const oldArr = ["a", "b", "c"];

const newArr = oldArr.slice(); //

newArr[0] = "ddd"; // изменим элеметн с индексом 0 у массива newArr

console.log(oldArr); // на выходе будет [ 'a', 'b', 'c' ]
console.log(newArr); // на выходе будет [ 'ddd', 'b', 'c' ], те.е поверхностная копия независимая

// Создание поверхностных копий при помощи оператора разворота Spread ... разворачивает структуру 
// и превращает ее в набор данных. (ES6 для массивов), (ES8 для объектов).


const video = ["youtube", "vimeo", "rutube"], //создадим массив video
	  blogs = ["wordpress", "livejornal", "rblogger"], //создадим массив blogs
	  internet = [...video, ...blogs, "vk", "facebook"]; // при помощи опереатора разворота ... Spread
// развернем их в новом массиве internet
console.log(internet); 
//на выходе будет массив
// ['youtube', 'vimeo', 'rutube', 'wordpress', 'livejornal', 'rblogger', 'vk', 'facebook']


// Рассмотрим пример посложнее создадим функцию log
function log (a, b, c) {
	console.log(a);
	console.log(b);
	console.log(c);
}

const num88 = [4, 5, 7]; // необходимо передать в функцию log в качестве аргументов элементы массива num88

// Cделаем это при помощи ...Spread оператора
log(...num88); // при помощи ...Spread оператора массив num88 разложится на 3 отдельные элемента 
// и данные элементы при вызове функции log() будут переданы в нее в качестве аргументов


// Создадим копию массива при помощи оператора ...Spread
const array = ["a", "b"]; // создадим массив array

const newArray = [...array]; // при помощи spread оператора создадим поверхностную копию массива array

newArray[0] = "g"; // изменим элемент под индексом 0 у полученного мастива newArray

console.log(array); // на выходе будет [ 'a', 'b' ]
console.log(newArray); // на выходе будет [ 'g', 'b' ] т.е. поверхностная копия независимая


// Создадим копию объекта при помощи оператора ...Spread
const Obj = {
	a: 55, 
	b: 88,
	c: 45
};

const newObj1 = {...Obj};

newObj1.a = 1000; // изменим свойство a у объекта newObj1

console.log(Obj);      // на выходе будет { a: 55, b: 88, c: 45 }
console.log(newObj1); // на выходе будет  { a: 1000, b: 88, c: 45 } т.е. поверхностная копия независимая



/// ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ (ООП) 

// ООП— это шаблон проектирования программного обеспечения, который позволяет решать задачи 
// с точки зрения объектов и их взаимодействий. 
// ООП обычно реализуется с помощью классов или прототипов. 
// Большинство объектно-ориентированных языков (Java, C++, Ruby, Python и др.) 
// используют наследование на основе классов. 
// JavaScript реализует ООП через прототипное наследование.

// Представить ООП можно в виде автомобиля.

// У автомобиля есть свойства: колеса, кузов, багажник, гос. номер, лобове стекло. 
// Данные свойтсва присущи почти каждому автомобилю
// Так же автомобиль может своершать какие-то действия: первозить людей и грузы, участвовать в гонках и т.д.

// Также и объектов в программировании.
// В JS мы представляем любую сущность как объект, с набором свойств и методов(действий).

// Пример

// У строки есть свойство length - длинна строки,
// так же есть методы для изменения ее регистра toLowerCase() toUpperCase().
// НО если строка написана просто окруженная ковычками, то это обычный примитив - тип данных строка.
// НО как только мы пытаемся вызвать какоето-то свойтсво строки или метод строки, то движок JS
// оборачивает эту строку в объект и после модификации, возвращает строку на место. 

// Пример

/* let str333 ="some";
let strObj = new String(str); //данным способом создания строк никто не пользуется, но для примера можно

console.log(typeof(str)); // на выходе будет тип данных String - строка
console.log(typeof(strObj )); // на выходе будет тип данных object - объект, 
// т.е. при модификации JS обернул строку в объект. */ 

// ПРОТОТИПЫ в JS сродни общему понятию ЛЕГКОВЫЕ АВТОМОБИЛИ. У каждого из них есть схожие свойства и 
// методы(действия), но так же у них разные марки, двигатели, коробки передач, разные радиусы колес и т.д.

// У одного общего ПРОТОТИПА(Объекта), могут быть разные потомки, у которых свои свойства и методы,
// НО они есть у каждого такого потомка. 

// Если мы в создаем строки или массивы, все они могу содержать совершенно разное наполнение.
// Но каждый из них обладает одними и теми же методами.
// Т.е. когда мы создаем массив, мы создаем новый экземляр прототипа массивов.
// воспользуемся командой чтобы посмотреть все свойства и методы прототипа Array (массивов)
console.dir([1, 2, 3, 4]);

// Любые конструкиции методов прототипно наследуются от объектов. 

// Для наследования свойств прототипа мы можеим использовать 2 формата записи

// 1-ый формат (уже устарел и его не стоит использовать в проектах), он встречается в legacy коде
// Создадим объект прототип солдата 
/* const solder = {
	health: 400,
	armor: 600
};

const Jonh = {
	health: 100

};

Jonh.__proto__ = solder; // установим прототипом solder для Jonh

console.log(Jonh); // выдаст { health: 100 }
console.log(Jonh.armor); // выдаст 600, т.е. Jonh унаследовал свойство armor прототипа solder */

// В реальных проектаъ мы можем создать один большой прототип напрмер модального окна, 
// которое по умолчпнию содержит определенные свойства (ширина, высота, бэкграунд). 
// А после, при создании новых модальных окон наследовать эти свойства у прототипа. 


// 2-ой формат записи (современный)
// В настоящее время для наследования свойств прототипа нужно использовать такие методы как:
// Object.create();  // создает объект с определенным прототипом
// Object.getPrototypeOf(); // получает созданный прототип
// Object.setPrototypeOf(); // устанавливает прототип для нужного объекта

const solder1 = {
	health: 400,
	armor: 600
};

const Jonh1 = {
	health: 100
};

Object.setPrototypeOf(Jonh1, solder1); // первым аргментом в метод getPrototypeOf пишем тот объект,
// для которого нужно установыить прототип это Jonh, 
// вторым аргументом тот объект, который будет прототипом это solder1
// Данный метод используется в динамике, т.е. объект для которого нужно установть прототип
// уже существует.

console.log(Jonh1); // выдаст { health: 100 }
console.log(Jonh1.armor); // выдаст 600, т.е. Jonh унаследовал свойство armor прототипа solder

// На этапе создания проекта мы уже на этапе создания объекта
// мы сразу используем метод Object.create();

const solder2 = {
	health: 600,
	armor: 1000
};

// Создаем новый объект Vasya, который прототипно наследуюется от объекта solder2 
const Vasya = Object.create(solder2); // аргументом мы в него можем сразу передать прототип solder2

console.log(Vasya.health); // на выходе будет 600, т.е. объект Vasya унаследовал свойство health
// у прототипа solder2


// ПРАКТИКА 4

// Задание на урок:

// 1) У нас уже есть рабочее приложение, состоящее из отдельных функций. Представьте, что
// перед вами стоит задача переписать его так, чтобы все функции стали методами объекта personalMovieDB
// Такое случается в реальных продуктах при смене технологий или подхода к архитектуре программы

// 2) Создать метод toggleVisibleMyDB, который при вызове будет проверять свойство privat. Если оно false - он
// переключает его в true, если true - переключает в false. Протестировать вместе с showMyDB.

// 3) В методе writeYourGenres запретить пользователю нажать кнопку "отмена" или оставлять пустую строку. 
// Если он это сделал - возвращать его к этому же вопросу. После того, как все жанры введены - 
// при помощи метода forEach вывести в консоль сообщения в таком виде:
// "Любимый жанр #(номер по порядку, начиная с 1) - это (название из массива)"*/

// выполним задание 1
 const personalMovieDB3 = {
	count: 0,
	movies: {},
	actors: {},
	genres: [],
	privat: true,
	start: function() {
		personalMovieDB3.count = +prompt("Сколько фильмов вы уже посмотрели?", "");

		while(personalMovieDB3.count == "" || isNaN(personalMovieDB3.count ) || personalMovieDB3.count == null) {
			personalMovieDB3.count = +prompt("Сколько фильмов вы уже посмотрели?", "");
		}
	},

	detectPersonalLevel: function() {
		if (personalMovieDB3.count < 10) {
			alert("Просмотрено довольно мало фильмов");
		} else if (personalMovieDB3.count >= 10 && personalMovieDB3.count < 30) {
			alert("Вы классический зритель");
		} else if (personalMovieDB3.count >= 30) {
			alert("Вы киноман");
		} else {
			console.log("error");
		}
	},  
/* 	writeYourGenres: function() {
 		for (let i = 1; i <=3; i++) { //Выполним задание 3
			const genre = prompt(`Ваш любимый жанр под номером ${i}`);
			if (genre == "" || genre == null) {
				i--;
			}else {
				personalMovieDB3.genres[i-1] = genre;
			}
		}
		personalMovieDB3.genres.forEach((item, i) => {
			console.log(`Любимый жанр №${i + 1} - это ${item}`);
		}); 
		
	}, */	
	//Выполним задание 3 при помощи метода split()
 		writeYourGenres: function() {
		for (let i = 1; i < 2; i++) {
			const genre = prompt("Введите три ваших любимsх жанра через запятую").toLowerCase();
			if (genre == "" || genre == null) {
				i--;
			}else {
				// используя метод split() разделим полученную строку от пользоваталтея и поместим 
				// ее в массив personalMovieDB3.genres
				personalMovieDB3.genres = genre.split(', '); 
				personalMovieDB3.genres.sort(); // отсортируем данные введенные пользователем по алфовиту
			}
		}
		personalMovieDB3.genres.forEach((item, i) => { // выполним 2-ую часть задания №3
			console.log(`Любимый жанр №${i + 1} - это ${item}`);
		});
	}, 
	rememberOfFilms: function() {
		for (let i = 0; i < 2; i++) {
			const lastFilms3 = prompt("Один из последних просмотренных фильмов?", ""),
				  rating3 = +prompt("На сколько оцените его?", "");
			//Выполним задание 2
			if (lastFilms3 == "" || rating3 =="" || lastFilms3 == null || rating3 == null || lastFilms3.length > 5) {
				i--;
			} else  {
				personalMovieDB3.movies[lastFilms3] = rating3; 
			}
		 
		} 
	},
	toggleVisibleMyDB: function() {
		if (personalMovieDB3.privat) { // если в условие попадает правда, то функция меняет его на fasle
			personalMovieDB3.privat = false;
		} else {
			personalMovieDB3.privat = true; // иначе в условие попадает false, то функция меняет его на true
		}
	},
	showMyDB:function() {
		if (personalMovieDB3.privat == false) {
			console.log(personalMovieDB3);
		}
	}
	
}; 

personalMovieDB3.start();
personalMovieDB3.detectPersonalLevel();
personalMovieDB3.writeYourGenres();
personalMovieDB3.rememberOfFilms();
personalMovieDB3.toggleVisibleMyDB();
personalMovieDB3.showMyDB(); 







