"use strict"; // включим строгий (современный) режим кода JS


/// ПЕРЕМЕННЫЕ

// Объявим переменную используя ключевое слово let 

/* let number = 10; // number - это имя переменной; знак = это знак присваиваивания; */
// 10 - это значение перпеменной, которе мы ей присвоили
// let обозначает, что наша переменная изменяема, т.е. мы можем изменить переменную,
// присвоив ей другое значение
// Пример:
// Обратимся к имени переменной number и присвоим ей другое значение
/* number = 55;
console.log(number); // выдаст 55, т.е. мы изменили значнеие переменной с 10 на 55 */

//Обяъвим переменную используя ключевое слово const 
/* const number1 = 20; // number1 - это имя переменной; знак = это знак присваиваивания; */
// 20 - это значение перпеменной, которе мы ей присвоили
// const обозначает, что наша переменная не изменяема, т.е. константа мы не можем 
// изменить переменную, присвоив ей другое значение
// Пример:
// Обратимся к имени переменной number1 и попробуем присвоить ей другое значение
/* number1 = 77;
console.log(number1); // выдаст ошибку TypeError: Assignment to constant variable. */
// Хорошим тоном в написание кода на JS является задание переменных через const везде, 
// где это возможно.
// Прямых констант в JS не существует и мы можем изменть значение переменной,
// заданной через const
// Пример:
// Создадим перменную с именем obj и положим в нее объект со парй ключ: значение
/* const obj = {
    a: 50
};

obj.a = 20; // После чего обратимся к свойству а объекта obj и изменим его значение
console.log(obj); // Выдаст { a: 20 }, т.е. мы поменяли значение свойства a c 50 на 20
// внутри объекта, который был присвоен как значение переменной obj */

// Имя переменной может состоять из букв, цифр, символов доллара $ и нижнего подчеркивания _
// Переменные записанные в разном регистре - это разные переменные: number Number и NUMBER
// Первый символ никогда не должен быть цифрой!!!
// Названия перменных не должны повторять зарезервированные слова в языке JS, например error,
// promt, alert и др.
// Перменные состоящие из нескольких слов записываются в формате CammelCase
// Важно назвать переменные осмысленно, ведь над ним в будущем будут работать другие люди

// Переменные let const видны только в блоке кода ограниченного круглыми скобками
// создадим объект и поменстим в него переменную
/* {
    let visible1 = 'noVisible';
    const visible = 'noVisible';
    console.log(visible, visible1); // получим noVisible noVisible - все ок
} */

// console.log(visible, visible1); // если запросим за пределами {}
// то получим ощибку visible is not defined т.е переменная не найдена


// Старый формат записи имени переменных и его проблемы

// Ранее для обозначения переменных использовалось ключевое слово var
// Данный формат записи переменных ни при каких обстоятельствах 
// мы не должны использовать в своем коде

/* console.log(name); // пытаясь оюратиться к переменной до ее объявления мы получим 
undefined var name = 'Ivan'; */
// Т.е. мы получаем не ошибку, а undefined данная переменная видна еще до ее объявления
// такое поведение при использование var называется hoisting (всплытие переменных)
// данное поведение может привести к очень не приятным и трудно отлавливаемым ошибкам

// Переменная созданная с помощью var видна и за пределами блока кода 
// ограниченного {}, т.е. переменная как бы "всплывает" в глобальную область видимости
// и это очень плохо с точки зрения логики
/* {
    var current = 10;
}
console.log(current); //выдаст 10 т.е. ошибки не будет т.к перменная "всплыла"  
// в глобальную область видимости */

// В старом стандарте JS можно было создать переменную без ее объявления через ключевое слово
// var
// Пример
/* a = 20;
console.log(a); */


// Современный формат записи кода используя директиву 'use strict';
// Данная деректива всегда записывсается в начале JS файла и говорит ему 
// что мы работатем в современном режиме JS, где уже не работают некоторые неточности,
// которые были в с тарых стандартах JS

// В новом формате используя строгий режим мы не можем объявлять переменные 
// не используя ключевых слов let или const
// Пример
/* "use strict";
 b= 20;
console.log(b); // получим ошибку ReferenceError: b is not defined */


/// ТИПЫ ДАННЫХ В JS

// Первая категория типов данных - простые типы(примитивы)

// Числа -  1, 2, 3
// Строки "string" - "name" это набор данных, которые мы можем описать словами
// Логический тип (bololean) - true / false это либо правда либо ложь
// null - специфический тип данных, это когда чего то-то просто не существует
// undefined - специфический тип данных, когда что-то существует, но у него нет значения
// Symbol -  представляет собой уникальный идентификатор.
// BigInt - тип данных отображающий большие числа (больше чем 2 в 53 степени)

// Вторая категория типов данных - комлексные типы или Объекты

// Подкатегория 1 - Спец объекты:          // Подкатегория 2 - Обычные объекты       
// Массивы []
// Функции function ()
// Объект даты
// Регулярные выражения
// Ошибки

// Разберем каждый из типов данных в частности:


// Тип данных Числа 

/* let number2 = 2;
let number3 = 4.5; // для дробных чисел используется именно точка, а не запятая */
// К числам относятся числовые значения, которые относятся к данному типу данных
// Пример
// Infinity (бесконечность) - числовое значение, получаемое при делении числа на 0
/* console.log(4 / 0); // выдаст Infinity (бесконечность)
console.log(-4 / 0); // выдаст -Infinity (минус бесконечность), получим при делении */
// отрицательно числа на 0
// NaN (Not a Number - не число)  - числовое значение получаемое в результате операции, 
// которая не подлежит математической логике
/* console.log(4 * "qwerty"); //выдаст NaN (не число)
// НО!!!
console.log(4* "111"); //выдаст строку '444' ВАЖНО помнить об этом!!! */


// Тип данных Строки

// Обязательным отрибутом строки являются кавычки, такие как: 
// Одинарные '', 
// Двойные "",
// Косые (бэктики) `` (косые кавычки используются для интерполяции 
// строк `qwerty ${43}`)

// Какаие кавычки использовать одинарные или двойные определяется стилистикой проекта,
// либо правилами заведенными в компании

/* const persone = "Alex"; */
// используя оператор typeof проверим тип данных присвоенных переменной persone
// Оператор typeof возвращает строку, указывающую тип операнда.
/* console.log(typeof(persone)); //выдаст "string" - строка */

/* const persone2 = `David`; // задание строк с помощью косых кавычек
console.log(typeof(persone2)); //выдаст "string" - строка */

/* const number4 = "888";  //строки помгу содержать в себе и цифры
// в случае если мы запишем цифры в кавычках, то тип данных у них будет не number, а string
console.log(typeof(number4)); //выдаст "string" - строка */


// Тип данных Логический тип данных bololean

/* const bool = true; // правда
const bool2 = false; // ложь */


// Тип данных null

// null - специфический тип данных, это когда чего то-то просто не существует

// Не объявляя перменную something попробуем вывести ее в консоль

/* console.log(something); // получим ошибку ссылочного типа 
// ReferenceError: something is not defined
// т.е. код не может сослаться на несуществующую переменную something */


// Тип данных Undefined 

//undefined -специфический тип данных, когда что-то существует, но у него нет значения

/* let a; // мы объявили переменную, но не присовили ей никакое значение 
console.log(a); // консоль нам выдаст undefined, т.е. перменная есть, 
//но ее значнеие не найдено */


// Тип данных Объект

// Объект - это коллекция данных, ключевая единица в JS
// данную струкутуру можно использовать для хранения абсолютно любых типов данных.
// Данные в объекте хранятся в формате ключ: значение и называются свойствами объекта.
// Так же в объекте могут содержаться какие-то дейсвтия - они называюися методы.
// Для создания объектов используются {}

/* const obj = {
    a: 23,
    b: "qwerty",
    c: [1, 3, 'asdfg'],
    isMaried: false
};  */
// Для доступа к определенному значению свойства объекта, мы долны обратиться к нему через
// имя объекта, а далее через точку указать ключ
// или черз квадратные скобки указать ключ заключенный в кавычки
// Пример
/* console.log(obj.a);  // через точку обращаемся к значению свойтсва a  - выдаст 23
console.log(obj['a']); // // через ['a'] обращаемся к значению свойтсва a  - выдаст 23 */

// Чтобы обратиться к элементу массива, который является значением определенного
// свойства объекта нужно так же указать имя объекта, затем через точку имя своства, 
// а затем в квадратных скобках указать порядковый индекс элемента массива
/* console.log(obj.c[2]); //выдаст строку 'asdfg'
// Так же можно это сделать используя только квадратные скобки
// Пример
console.log(obj["c"][1]); //выдаст число 3 */

// Частным случаем объекта явлется МАССИВ

// ВАЖНО!!! Массив это НЕ отдельный тип данных, а именно частный случай объекта
// Массив это структура для хранения данных, которые идут СТРОГО!!! по по порядку
// Во внутрь массива, точно так же как и во внутрь объекта можно положить любой тип данных
/* let arr = ['pic1.png', 'pic2.png', 'pic3.png', 'pic4.png', {}, [], 454, NaN]; */

// Для того, чтобы обратиться к определенному элементу массива нужно указать его имя, 
// а затем в квадратных скобках указать порядковый индекс элемента этого массива
// Пример

/* console.log(arr[4]); // выдаст элемент массива arr с порядковым индексом 4 - это 
// пустой объекn {}
console.log(arr[0]); // выдаст элемент массива arr с порядковым индексом 0 - это 
// строка 'pic1.png' */
// ВАЖНО!!! В программировании нумерация начинается не с единицы (1), а с нуля (0)

//Для доказательства, что массив это частный случай объекта, а не отдельный тип данных
//рассмотрим его более детально

//Объект преставляет собой стурктуру с данными хранящимися в формате ключ: значение

// В массиве ключами будут являться его порядковые индексы 0, 1, 2, 3, 4 и т.д.
// А значенимями свойств будут являться сами элменты массива 
/* //свойства:  ключ №0      ключ №1     ключ №2     ключ №3    ключ №4
let arr1 = ['pic1.png', 'pic2.png', 'pic3.png', 'pic4.png',    {},        [], 454, NaN]; */


/// ВЗАИМОДЕЙСТВИЕ С ПОЛЬЗОВАТЕЛЕМ

// Способ №1 с помощью функции интерфейсa браузера alert

// Функция интерфейса браузера alert показывает сообщение в модальном окне браузера 
// и ждёт, пока пользователь нажмёт кнопку «ОК».
// Функция интерфеса alert чаще всего используется для того, 
// чтобы предупредить пользователя о чем-то важном.
// ВАЖНО!!! отметить, что данная функция будет работать ТОЛЬКО в браузере,
// в консоли VSCode она работать не будет. Вылетающее окно будет невозможно застилизовать.

/* alert("Привет user"); // вылетит модальное окно со строкой "Привет user" и кнопокой Ok */

// Способ №2 с помощью функции интерфейсa браузера confirm

// Функция интерфейса confirm отображает модальное окно с текстом вопроса question 
// и двумя кнопками: OK и Отмена.
// ВАЖНО!!! отметить, что данная функция будет работать ТОЛЬКО в браузере,
// в консоли VSCode она работать не будет. Вылетающее окно будет невозможно застилизовать.

/* confirm("Вам есть 18 лет?"); // вылетит модальное окно со строкой-вопросом
// "Вам есть 18 лет?" и кнопоками Ok и Отмена */

//Так же мы можем записать ответ пользователя в перменную

/* const result = confirm("Вам есть 18 лет?");
// после чего полученные данные мы сможем использовать в дальнейшем
console.log(result); // в консоли будет булиновое значение или 
// true в случае, если пользователь нажмет кнопку Ok или 
// false в случае, если пользователь нажмет кнопку Отмена */

// Способ №3 с помощью функции интерфейсa браузера prompt

// Функция интерфейса prompt отобразит модальное окно с текстом, 
// полем для ввода текста и кнопками OK/Отмена.
// Данная функция необходима, для получения информации от пользователя,
// которую он введет в поле для ввода текста. Полученную инфу можно будет записать в 
// переменную и использовать ее в дальнейшем, к примеру внося инфу в БД.

/* const answer = prompt("Сколько будет 2 + 2?", ""); // после вопроса пользователю */
// мы ставим запятую, окрываем ковычки и оставляем их пустыми, либо
// вставляем дефолтный ответ (placeholder), который пользователь сможет стереть 
//и написать свой ответ.
// Пример 
/* const answer1 = prompt("Сколько будет 2 + 2?", "4, 5 или 6?");
console.log(answer);
console.log(answer1);
// ВАЖНО!!! Все данные приходящие от пользователя всегда будут иметь тип данных string
// вне зависимости от способа их получения.
console.log(typeof(answer1)); // выдаст string - тип строка */

// Для того чтобы преобразовать строковый тип данных string в числовой number
// можно использовать оператор унарный плюс +, который ставится напрмер перед комадой prompt
// Унарный + ставится всегда перед чем-то. 
// Унарный + использует только один аргумент для своей работы
/* const answer2 = +prompt("Сколько будет 5 + 12?", "4, 5 или 6?");

console.log(typeof(answer2)); // выдаст number
console.log(answer2 + 4); // если пользователь введет число то в консоль выдаст результат
// сложения числа которе ввел пользователь и 4. */

// Зададим вопросы пользователю и запишем его ответы в массив arr2
/* const arr2 = [];
// По порядку обратимся к порядковым индексам массива arr2 и запишем в них данные
// полученные от пользователя
arr2[0] = prompt("Как Вас зовут?", ""); 
arr2[1] = +prompt("Cколько вам лет?", ""); 
arr2[2] = prompt("Какие языки программирования вы знаете?", "");
arr2[3] = +prompt("Сколько лет вы программируете на JS", "");

console.log(arr2); // в консоль выведем получивышийся массив arr2 c ответами пользователя
console.log(typeof(arr2)); // выведет object, что еще раз подтверждает, что массив - это
// частный случай объекта. */

// Одним из первых методов используемых в JS был document.write
// Метод document.write – один из наиболее древних методов добавления текста к документу, но
// заменяет все содержимое сайта и в реальных проектах не используется.
// Мы можем использовать данный метод для тестов, чтобы к примеру вывести на страницу массив
// с ответами от пользователя.
/* document.write(arr2); */
// ВАЖНО!!! Функции интерфейса alert, confirm и prompt блокируют построение страницы до того
// момента пока они не будут выполнены. 

// ВАЖНО!!! Оффтоп НО, если вывести тип данных переменной, которой присвоен 
// специфический тип данных null обозначающий то, чего не существует консоль нам высдаст 
// object
/* const nothing = null;
console.log(typeof(nothing));
// ЭТО ЯВЛЯЕТСЯ ПРИЗНАННОЙ ОШИБКОЙ В JS. null является отдельным специфическим типом данных. */


/// ИНТЕРПОЛЯЦИЯ в JS

// Ранее для того, чтобы вставить в строку значнеие переменной использовалась
//конкатенация (склеивание) строк.
// Пример
// Для того чтобы сформировать URL путь в отдельную категорию игрушки пропишем следующее
/* const category = "toys";
//Теперь выведем в консоль путь в категорию игрушки старым методом используя конкатенацию
console.log("https://www.storeyourtoys.com/" + category);  */

// Интерполяция позволяет вставлять во внутрь строки значение пеперменной при помощи
// косых ковычек и ${}
// Cформируем тот же самый путь в категорию игрущки используя интерполяцию и вставим значение
// переменной category непосредственно в саму строку используя косые кавычки (бэктики) и ${}
/* console.log(`https://www.storeyourtoys.com/${category}`); */

// Используя интерполяцию можно получить данные от пользователя, записать их в переменную,
// а затем вставить значние переменной например в alert.
/* const nameUser = prompt("Как тебя зовут?", "");
alert(`Привет, ${nameUser}!`);
*/


/// ОПЕРАТОРЫ В JS

// Оператор + стоит особняком среди других операторов таких как:

// сложения +, 
// вычетания -,
// умножения *,
// деления /

// Если оператор сложения + применить к 2-ум строкам, то эти две строки склеятся между
// собой. 
// Даже если к строке прибавить число, на выходе будет срока.
// Данная операция называется конкатенация (склеивание).

// Пример

/* const row1 = "this is row one";
console.log(row1 + " this is row two"); //строка из переменной row1 склеится 
// со строкой " this is row two", на выходе будет this is row one this is row two
console.log(row1 + 1); // на выходе будет this is row one1. 
console.log(typeof(row1 + 1)); // Выдаст string - строка */
// Если мы захотим преобраховать строку в число, посредством унарного +, 
// и сложим получившееся число с другим числом, то

/* console.log(+"row3" + 4); //на выходе получим NaN (не число) т.к. мы выполняем дейтсвие,
// которое не подлежит математической логике, 
// т.к. мы пытаемся преобразовать буквы в число. */

//Но если мы попытаемся преобразовать число с типом данных string и прибавть к нему другое 
// число, у нас все получится
/* console.log(+"5" + 4); // на выходе получим 9, т.к. 5-ка из строки превратилась в число */

// Операторы инкремента ++ и декремента --

// Операторы инкремента ++ и декремента -- слжат для укорочения нашего кода

// Оператор инкремента ++ увеличивает значение на единицу

// Оператор декремента -- уменьшает значение на единицу

// Важно!!! Частый вопрос на собесодованиях - 
// Чем отличается перфиксная форма записи инкремента и декремента от постфиксной

// Оветим на данный вопрос на примере

/* let incr = 5,
    decr = 10;

incr++; // постфиксная форма записи инкремента
decr--; // постфиксная форма записи декремента

console.log(incr); // на выходе будет 6
console.log(decr); // на выходе будет 9

++incr; // префиксная форма записи инкремента
--decr; // префиксная форма записи декремента

console.log(incr); // на выходе будет 6
console.log(decr); // на выходе будет 9 */

// и вроде как отличий никаких нет НО!!!

//САМОЕ ВАЖНОЕ!!!
//Если мы поставим знаки инкремента и декремента прямо во время их использования в console.log
// картина будет совсем иная

/* let incr1 = 10,
    decr1 = 20;

console.log(incr1++); // на выходе будет 10, т.е. ничего не извменится
console.log(decr1--); // на выходе будет 20, т.е. ничего не извменится

// НО ЕСЛИ ЗАПУСТИТЬ console.log еще раз

console.log(incr1++); // на выходе уже будет 11, т.е. инкремент уже сработал 
console.log(decr1--); // на выходе уже будет 19, т.е. инкремент уже сработал  */ 
     
// В случае, если мы используем инкремент и декремент в постфиксной форме записи
// прямо сразу в console.log или еще где-то, то сначала
// нам возвращается первоначалльное значение, а затем уже увеличенное или 
// уменьшенное на единицу

// В префиксной форме записи ситацация совершенно противоположная.
// Нам СРАЗУ возвращается увеличиенное или уменьшенное на единицу значение

/* let incr2 = 10,
    decr2 = 20;

console.log(++incr2); // на выходе будет 11
console.log(--decr2); // на выходе будет 19 */

// В циклах оперторы инкремента и декремента будут использоваться очень часто. 

// Как и в математике в JS применятся операторы 

// больше >
// меньше <
// больше либо равно >=
// меньше либо равно <=
// равно ==              // в JS одинарный знак = это оператор присваивания, а не сравнения
// не равно != (не строгое сравнение) !== (строге сравнение учитывая тип данных)
// логический оператор И - записывается как два амперсанта &&
// логический оператор ИЛИ - записывается как два вертикальных слеша ||
// побитовые опреаторы (в данном курсе мы их затрагивать не будем)
// Оператор отрицания ! обращает значение на противополжное, правду в ложь, ложь в правду
// возврат остатка от деления двух чисел %



// Пример использования возврата остатка от деления двух чисел %

/* console.log(5 % 2); // на выходе будет 1, т.к. 5-ка делится на 2 ровно 2 раза, в остатке 1 */

// Подробнее об операторе не строгого равенства == и строгого равенства ===

// Не строгое сравнение == это когда при сравнении не учитывается тип данных

/* console.log(2 * 4 == "8"); // на выходе будет true, т.е. тип данных не учитывается, 
// учитывается только значнеие и число 8 равно сроке со значением 8. */

// Строгое сравнение === это когда при сравнении учитывается тип данных

/* console.log(2 * 4 === "8"); // на выходе будет false т.к. тип данных уже учитывается, 
// и число 8 не равно сроке со значением 8. */

// Подробнее об логических опретаторах И && и ИЛИ ||

// Логический оператор И && работает только тогда, когда два или больше значений 
// являются правдивыми выражениями, т.е. И это правда И это правда

// Пример
// Проверим, что какая-то галочка на странице отмечена, и какое-то модальное окно закрыто
/* const isChecked = true,
      isClosed = true;
console.log(isChecked && isClosed); // на выходе будет true, т.к. и первое выражение правдиво
// и второе выражение правдиво. */

/* // В случае если 
const isChecked1 = true,
      isClosed1 = false;
console.log(isChecked1 && isClosed1); // на выходе будет false, т.к. первое выражение правдиво,
// а второе выражение уже не правдиво. */

/* const isChecked2 = false,
      isClosed2 = false;
console.log(isChecked2 && isClosed2); // на выходе будет false, т.к. и первое выражение 
// не правдиво, и второе выражение не правдиво. */

// Логический оператор ИЛИ || работает тогда, когда одно из значений 
// является правдивым выражением, т.е. ИЛИ это правда ИЛИ это правда

/* const isChecked3 = true,
      isClosed3 = true;
console.log(isChecked3 || isClosed3); // на выходе будет true, т.к. первое выражение правдиво,
// а второе выражение уже не важно правдиво или нет. */

/* const isChecked4 = false,
      isClosed4 = true;
console.log(isChecked4 || isClosed4); // на выходе будет true, т.к. второе выражение правдиво,
// а певрое уже не важно правдиво или нет. */

/* const isChecked5 = false,
      isClosed5 = false;
console.log(isChecked5 || isClosed5); // на выходе будет false, т.к. и первое выражение 
// не правдиво, и второе выражение не правдиво. */

// Оператор отрицания !

//Оператор отрицания ! обращает булинове значение в противоположное, 
//правду в ложь, ложь в правду
/* console.log(!(false)); // на выходе будет true
console.log(!(true)); // на выходе будет false */

// Оператор не равно !=

/* console.log(2 + 2 * 2 != "6"); // на выходе получим false, т.к. если не учитывать тип данных
// то число 6 равно строке "6" */

/* console.log(2 + 2 * 2 !== "6"); // на выходе получим true, т.к. если учитывать тип данных
// и сравнивать строго, то число 6 не равно строке "6" */

/* console.log(2 + 2 * 2 != 7); // на выходе получим true, т.к. число 6 не равно числу 7 */

// Порядок выполнения операторов
// Табличка приоритетов использования кодом операторов
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table


/// СИСТЕМА КОНТРОЛЯ ВЕРСИЙ Git и СЕРВИС ХРАНЕНИЯ УДАЛЕННЫХ РЕПОЗИТОРИЕВ GitHub

// Git - это система контроля версий для проектов и создания контрольных точек.
// GitGub - это удаленное хранилище репозиториев.
// Система Git позволяет сохранять контрольные точки буквально за несколько команд  
// Все контрольные точки и изменения в проекте можно сохранять в репозитории, который позволит:
// посмотреть где, что и когда было изменено в проекте
// откатиться на старую версию проекта
// снова вернуться на новую версию проекта
// Так же Git позволяет экономить память, т.к. статичные (не измененные) файлы не копируются
// снова и снова.
// С репозиторием могут работать несколько человек, над большими реальными проектами, как 
// правило, трудится целая команда разработчиков.

// Даже если работать над проектом в одно лицо, сохранение изменений в репозиторий чрезвычайно
// важно, т.к. с компом может случиться все что угодно, либо закзачик может попросить вернуть
// те изменения, которые были несколько месяцев назад.

//Порядок установки Git'a

// 1) Скачать последнюю версию Git c сайта https://git-scm.com/
// 2) Туториал как пользоваться Git'ом можно посмотреть на https://githowto.com/ru
// 3) После установки Git'a можно юзать GUI (Графический интерфейс пользователя) 
// данное меню появляется если нажать правой кнопокой на любом файле (способ не удобен)
// 4) Можно использовать командную строку cmd. Чтобы попасть в нужную папку, а затем
// использовать Git c ее содержимым нужно набрать команду cd и через пробел указть путь
// который ведет к нужным файлам.
// 5) Вместо командной строки cmd, можно так же использовать PowerShell.
// 6) !!! НО Мы будем юзать Git прямо в VSCode!!!

// В VScode есть тот же интерфейс что и в командной строке cmd или PowerShel
// Отвечает за это вкладка Терминал.

// Порядок работы с Git'ом
// 1) Для инициализация работы Git'а в терминале набираем команду git init
// мы получим ответ Initialized empty Git repository in и в папке с проектом паявится 
// скрытая папка .git - это и есть наш репозиторий.
// 2) Необходимо законфигурировать файлы проекта:
// Конфигурировать файлы мы можем как локально так и глобально
// Глобальная конфигурация (настройки для всех файлов компьютера) позволяет создвать все 
// проекты от нашего имени.
// Локальная конфигурация (настройки для файлов отдельного проекта) позволяет создвать 
// проект указав уже любое доругое имя разработчика проекта. 
// При указании локальной конфигурации для конкретного проекта глобальные 
// данные уже не будут распространяться на него.

// Пропишем две конфигурационные команды, чтобы представить себя:
// Для локальной конфигурации прописываем следующее 
// git config --local user.name "F1icker"
// git config --local user.email fl1ck@yandex.ru (уже без кавычек)

// Для глобальной конфигурации прописываем следующее 
// git config --global user.name "F1icker"
// git config --global user.email fl1ck@yandex.ru (уже без кавычек)

// У Git репозитория есть три состояния файлов 
// 1-ое состояние - это когда фалы просто созданы
// 2-ое состояние - это когда Git следит за определенными файлами (файлы попали в index)
// 3-е состояние файлов - это когда Git создал контрольную точку к которой мы сможем вернуться
// и посмотреть какие были изменения, как работал проект в данной контрольной точке и т.д.
// Данное состояние называется commit

// Для того чтобы посмотреть в каком состоянии находятся фалы в проекте пропишем команду
// git status

// Красным цветом подсвечены все файлы, которые етсь в проекте, 
// Git за ними не следит (состояние 1)

// Чтобы переключить ветку с master на main необходимо прописать команду 
// git branch -M main

// Чтобы перевести файлы проекта во 2-ое состояние (добавить их в index) пропишем команду
// git add -A 
// Все файлы за которыми Git не следил, будут добавлены в отслеживание их цвет станет зеленым
// Если к примеру нужно добавить в отслеживание новые файлы пропишем команду
// git add имяНовогоФайла.расширениеФайла
// или 
// git add *.расширение файла (тогда будут добавлены все не остлеживающиеся фалы с данным
// расширением)
// Чтобы сбросить последнее измененеие файла можно пропсаить команду
// git restore имяНовогоФайла.расширениеФайла, это аналог сочетнаия клавишь Ctrl+Z

// Чтобы перевести файлы в 3-е состояние и создать контрольную точку пропишем команду
// git commit -a -m"first commit"
// Чтобы сбросить последний commit до предыдущего commit'a можно прописать команду
// git checkout имяНовогоФайла.расширениеФайла

// Чтобы посмотреть какие commit'ы были сделаны пропишем команду 
// git log

// Для выгрузки commit'ов на удаленный репозиторий в GitHub нужно:
// 1) Для начала нужно в учетке GitHub создать новый репозиторий
// 2) Прописать имя репозитория
// 3) Прописать описание Description(не обязательно)
// 4) Выбрать профиль репозитория Публичный Public (доступен всем) или Приватный Private
// 5) Прописываем удаленный репозиторий, в который будут выгружены наши Commit'ы
// для этого прописываем команду 
// git remote add origin https://github.com/F11cker/JS_lecture_notes.git
// После ввода данной команды наш локальный репозиторий (на нашем компе) 
// будет связан с удаленным репозиторием на GitHub
// Чтобы запушить commit'ы на GitHub прописываем команду
// git push -u origin main

// Кратко все команды по порядку:

// git config --local user.name "F1icker" (только в начале работы над новым проектом)
// git config --local user.email fl1ck@yandex.ru (уже без кавычек) (только в начале работы)
// git status 
// git branch -M main
// git add -A 
// git commit -a -m"first commit"
// git log
// git remote add origin https://github.com/F11cker/JS_lecture_notes.git (только в начале работы)
// git push -u origin main (для следующих commit'ов можно импользовать команду git push)

// Работа с репозиторием на GitHub с разных аккаунтов
// Например с работа с репозиторием с домашнего компа и с рабочего

// 1) Клонирование репозитория с которым ведется работа
// Для этого есть два способа:
// Способ №1 - зайти на GitHub в нужный репозиторий и внутри нажать зеленую кнопку
// Code и далее скачать ZIP архив с проектом
// Способ №2 с зайти в терминал VSCode и восопользваться командой 
// git clone + путь к репозиторию который мы хотим скопировать
// для того, чтобы клонировать данный репозиторий. (Это наиболее правильный способ)
// Для того, чтобы зайти в нужную папку на том компе, на которм в данный момент ведется работа
// нужно набрать следующие команды в терминале:
// cd..
// cd имяНужнойПапки
// git clone https://github.com/F11cker/JS_lecture_notes.git  имяНужнойПодПапки
// Клонирование репозитория автоматически связывает новый локальный комп 
// с удаленным репозиторием. 
// Тем самым мы сразу можем делать commit'ы в проекте и пушить их в данный удаленный реп.
// Для этого можно сразу набирать команду 
// git push

// 2) Чтобы при возвращении на, к примеру, домашний компьютер получить все те изменения проекта,
// которые были сделаны на рабочем компьютере и работать с его последней версией нужно ВСЕГДА
// перед началом работы прописывать команду 
// git pull
// В случае, если мы не пропишем команду git pull перед началом работы с проектом и попытаемся
// запушить созданные нами commit'ы мы получим ошибку, т.к. в удаленном репозитории может
// оказаться более новая версия проекта чем у нас на компьютере, на которым мы в данный момент
// работаем.
// ВСЕГДА ПРОПИСЫВАЙ git pull ПЕРЕД НАЧАЛОМ РАБОТЫ!!!

// В случае если вознимает ситуация слияния (Merge) локального и удаленного репозитория то 
// 1) Задаем сообщение commit'a
// 2) Прожимаем 2 раза Ctrl + C
// 3) Прописываем команду :wq! + Enter
// 4) Git push

// Игнорирование файлов при работе Git и GitHub (используем файл .gitignore)

// При работе с проектом, чаще всего мы не хоим пушить в удаленный репозиторий различные 
// рабочие файлы напрмер папку node_modules

/// ПРАКТИКА №1

// Задание на урок:

//1) Создать переменную numberOfFilms и в неё поместить ответ от пользователя на вопрос:
// 'Сколько фильмов вы уже посмотрели?'

//2) Создать объект personalMovieDB и в него поместить такие свойства:
    // - count - сюда передается ответ на первый вопрос
    // - movies - в это свойство поместить пустой объект
    // - actors - тоже поместить пустой объект
    // - genres - сюда поместить пустой массив
    // - privat - в это свойство поместить boolean(логическое) значение false

//3) Задайте пользователю по два раза вопросы:
    // - 'Один из последних просмотренных фильмов?'
    // - 'На сколько оцените его?'
// Ответы стоит поместить в отдельные переменные
// Записать ответы в объект movies в формате: 
/*     movies: {
        'logan': '8.1'
    } */

// Проверить, чтобы все работало без ошибок в консоли 

// Выполним задачу №1
/* const numberOfFilms = +prompt("Сколько фильмов вы уже посмотрели?", "");
// Выполним задачу №2
const personalMovieDB = {
    count: '',
    movies: {},
    actors: {},
    genres: [],
    privat: false
};

personalMovieDB.count = numberOfFilms;
// Выполним задачу №3
const lastFilms = prompt("Один из последних просмотренных фильмов?", ""),
      rating = +prompt("На сколько оцените его?"),
      lastFilms1 = prompt("Один из последних просмотренных фильмов?", ""),
      rating1 = +prompt("На сколько оцените его?");

personalMovieDB.movies[lastFilms] = rating; 
personalMovieDB.movies[lastFilms1] = rating1;
// Записывать данные в объект который лежит внутри другого объекта лучше через [], 
// а не через точку.
console.log(personalMovieDB); // выведем все в консоль. */

/// УСЛОВИЯ в JS

// Все условия начинаются с оператора if (если)

// if (в круглых скобках пишем условие, которое хотим проверить) {
        // в фигурных скобках записываем то, что случится, если условие верно (true)
        // напрмер console.log("ok!");
// } else {   // Вторая часть условия начинается с else (иначе)
    // в фигурных скобках записываем то, что случится, если условие if не верно (false)
    // напрмер console.log("НЕ ok!");
// }
// Т.е. услвие внутри круглых скобок должно быть преобразовано к булиновому типу true / false

// Пример
if (9 == 9) {
    console.log("ok!");
} else {
    console.log("Error!");
}

// В случае, если в условие поместить одно число, отличное от 0, 
// то оно будет всегда будет возвращать true. 
// Число отличное от 0 в своем логическом контексте всегда true

// Пример
if (4) {
    console.log(true); // вернет true
} else {
    console.log(false);
}

// Но если поместить 0, то оно вернет false 
// 0 в своем логическом контексте всегда false 
// Пример
if (0) {
    console.log(true); 
} else {
    console.log(false); // вернет false
}

// Вложенность условий

const num = 50;

if (num < 49) {
    console.log("Error!"); 
} else if (num > 100) { // условие if не правда, проверяем следующее (это и есть вложенность)
    console.log("too much!");
} else {
    console.log("Ok!");
}                   

// Запись условий при помощи тернарного оператора

// Тернарный  оператор - единственный оператор в JavaScript, 
// принимающий три операнда: условие, за которым следует знак вопроса (?), 
// затем выражение, которое выполняется, если условие истинно, 
// сопровождается двоеточием (:), и, наконец, выражение, которое выполняется, 
// если условие ложно. 
// Он часто используется в качестве укороченного варианта условного оператора if.
// Синтаксис следующий:
// В круглых скобках пишем условие, которое хотим проверить
// После знака вопроса ? прописывается то, что произойдет, если условие вернет true
// После знака двоеточия : прописывается то, что произойдет, если условие вернет false

// Пример
const num1 = 40;
(num1 === 40) ? console.log("Ok!") : console.log("Error!"); 

///////////////////////////////////////////////////////////////////////////////////////////
// ВАЖНЫЙ ОФТОП

// 4 + 4 // в данном случае + это бинарный оператор (принимает 2 операнда)

// +"4"  // в данном случае + это унарный оператор (принимает 1 операнд)

// условие ? выражение1 : выражение2 // ? и : в совокупности являются тернарным оператором
////////////////////////////////////////////////////////////////////////////////////////////

// Конструкиця switch. 
// ВАЖНО!!! Конструкция switch ВСЕГДА ИДЕТ НА СТРОГОЕ СРАВНЕНИЕ!!! ===
// Для того чтобы избежать большого количества вложенности условий существую конструкция
// switch, которая поддерживает сразу неслько проверок и условий
// Синтаксис следующий
// В круглые скобки(в условие) мы помещаяем объект того что мы будем сравнивать
// и что проверять (просто передаем имя переменной)
// В фигурных скобках прописываем директиву case и через пробел записываем то, 
// с чем будем сравнивать значение нашей переменной.
// Ставим знак двоеточия : и после него пишем то, что произойдет если условие вернет true
// После каждого дейтсвия мы должны записать ключевое слово break и ставить знак ;
// В конце записывается действие по умолчанию default, которое сработает если не один из case'ов
// не вернет true.
// После так же прописываем break;

const num2 = 50;
switch (num2) {
    case 49:
        console.log("error");
        break;
    case 100:
        console.log("error");
        break;
    case 50:
        console.log("ok!");
        break;
    default: 
        console.log("nothing");
        break;  
}

// Со строками все работает точно так же, идет строгое сравнение.


/// Циклы

// Циклы - простой способ сделать какое-то однотипное действие несколько раз.

// В JS реализовываются 3-мя способами. Каждый из них исппользуется в зависимости от ситуации

// Способ №1 цикл while
// Дословно - ПОКА условие выполняется мы будем повторять какие-то действия
// Цикл while похож на условия.
let num3 = 50;

while(num3 <= 55) {     // в круглых скобках мы записываем условие
    console.log(num3); // в фигурных скобках мы записываем действия, которые будут выполняться 
    num3++;            // циклом пока условие не выполнится          
  
}

// Способ 2 цикл do
// Цикл do Сначала что-то делает, затем проверяет условия, и если необходимо выходит из цикла

let num4 = 80;

do {                   // сначала пишем ключевое слово do
    console.log(num4); // в фигурных скобках прописываем действия которые будет выполнять цикл
    num4++;
} while(num4 < 85);    //Проверку условия размещаем под телом цикла

// Способ 3
// Цикл for - самый распространённый цикл 
// Синтаксис следующиий
// Пишем ключевое слово for
// Далее в круглых скобках прописываем условие состоящиее из 3-ех аргументов
// let i (итератор) задаем переменную с которой нвчинается цикл for - это условие 1
// i < 8 (как пример) условие 2 - это условие, при котором цикл for остановит свою работу
// условие 3 - это шаг цикла for чаще всего используется инкремент. Пример i++
let num5 = 100;

for (let i = 0; i < 8; i++) { // между аргументами условий цикла обязательно ставится знак ;
    console.log(num5);         // в круглых скобках записываются действия, 
    num5++;                   // которые будет выполнять цикл на каждой его итерации
}      
// Данный цикл можно сделать бесконечным если прописать i < 0, нужно быть с эти осторожным

// Иногда возникает необходимость закончить цикл досрочно, напрмер если i примет какое-то
// специфическое значение
// для этого используется ключевое слово break
// Пример

let num6 = 100;

for (let i = 0; i < 8; i++) { 
    if (num6 === 106) {
        break;                //ключевое слово break полностью прервет цикл
    }
    
    console.log(num6);         
    num6++;                 
} 

// Иногда возникает необходимость пропустить шаг цикла, напрмер если i примет какое-то
// специфическое значение
// для этого используется ключевое слово continue
// Пример

let num7 = 2;

for (let i = 0; i < 12; i++) { 
    num7++;                      // если выражение поставть после conosle.log - continue
    if (num7 === 5) {            // сработает как break
        continue;                //ключевое слово continue пропустит шаг цикла
    }
    console.log(num7); 
                  
} 


// Практика №2

// Задание 

// 1) Автоматизировать вопросы пользователю про фильмы при помощи цикла

// 2) Сделать так, чтобы пользователь не мог оставить ответ в виде пустой строки,
// отменить ответ или ввести название фильма длинее, чем 50 символов. Если это происходит - 
// возвращаем пользователя к вопросам опять

// 3) При помощи условий проверить  personalMovieDB.count, и если он меньше 10 - вывести сообщение
// "Просмотрено довольно мало фильмов", если от 10 до 30 - "Вы классический зритель", а если больше - 
// "Вы киноман". А если не подошло ни к одному варианту - "Произошла ошибка"

// 4) Потренироваться и переписать цикл еще двумя способами*/

// Код возьмите из предыдущего домашнего задания

const numberOfFilms2 = +prompt("Сколько фильмов вы уже посмотрели?", "");

const personalMovieDB2 = {
    count: '',
    movies: {},
    actors: {},
    genres: [],
    privat: false
};

personalMovieDB2.count = numberOfFilms2;
// Выполним задание №3
if (personalMovieDB2.count < 10) {
    alert("Просмотрено довольно мало фильмов");
} else if (personalMovieDB2.count >= 10 && personalMovieDB2.count < 30) {
    alert("Вы классический зритель");
} else if (personalMovieDB2.count >= 30) {
    alert("Вы киноман");
} else {
    console.log("error");
}

// Выполним задание №1
for (let i = 0; i < 2; i++) {
    const lastFilms2 = prompt("Один из последних просмотренных фильмов?", ""),
          rating2 = +prompt("На сколько оцените его?");
    //Выполним задание 2
    if (lastFilms2 == "" || rating2 =="" || lastFilms2 == null || rating2 == null || lastFilms2.length > 5) {
        i--;
    } else  {
        personalMovieDB2.movies[lastFilms2] = rating2; 
    }
 
} 

// Выполним задание 4
// При помощи цикла while
/* let i = 0;
while (i < 2) {
    const lastFilms2 = prompt("Один из последних просмотренных фильмов?", ""),
    rating2 = +prompt("На сколько оцените его?");
    //Выполним задание 2
    if (lastFilms2 == "" || rating2 =="" || lastFilms2 == null || rating2 == null || lastFilms2.length > 5) {
    i--;
    } else  {
    personalMovieDB2.movies[lastFilms2] = rating2;
    i++; 
}
} */

// При помощи цикла do ... while
/*  let i = 0;
do {
    const lastFilms2 = prompt("Один из последних просмотренных фильмов?", ""),
    rating2 = +prompt("На сколько оцените его?");
    //Выполним задание 2
    if (lastFilms2 == "" || rating2 =="" || lastFilms2 == null || rating2 == null || lastFilms2.length > 5) {
    i--;
    } else  {
    personalMovieDB2.movies[lastFilms2] = rating2;
    i++;
    }
} while(i < 2); */

console.log(personalMovieDB2); // выведем все в консоль. 





















