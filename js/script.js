"use strict"; // включим строгий (современный) режим кода JS


/// ПЕРЕМЕННЫЕ

// Объявим переменную используя ключевое слово let 

/* let number = 10; // number - это имя переменной; знак = это знак присваиваивания; */
// 10 - это значение перпеменной, которе мы ей присвоили
// let обозначает, что наша переменная изменяема, т.е. мы можем изменить переменную,
// присвоив ей другое значение
// Пример:
// Обратимся к имени переменной number и присвоим ей другое значение
/* number = 55;
console.log(number); // выдаст 55, т.е. мы изменили значнеие переменной с 10 на 55 */

//Обяъвим переменную используя ключевое слово const 
/* const number1 = 20; // number1 - это имя переменной; знак = это знак присваиваивания; */
// 20 - это значение перпеменной, которе мы ей присвоили
// const обозначает, что наша переменная не изменяема, т.е. константа мы не можем 
// изменить переменную, присвоив ей другое значение
// Пример:
// Обратимся к имени переменной number1 и попробуем присвоить ей другое значение
/* number1 = 77;
console.log(number1); // выдаст ошибку TypeError: Assignment to constant variable. */
// Хорошим тоном в написание кода на JS является задание переменных через const везде, 
// где это возможно.
// Прямых констант в JS не существует и мы можем изменть значение переменной,
// заданной через const
// Пример:
// Создадим перменную с именем obj и положим в нее объект со парй ключ: значение
/* const obj = {
	a: 50
};

obj.a = 20; // После чего обратимся к свойству а объекта obj и изменим его значение
console.log(obj); // Выдаст { a: 20 }, т.е. мы поменяли значение свойства a c 50 на 20
// внутри объекта, который был присвоен как значение переменной obj */

// Имя переменной может состоять из букв, цифр, символов доллара $ и нижнего подчеркивания _
// Переменные записанные в разном регистре - это разные переменные: number Number и NUMBER
// Первый символ никогда не должен быть цифрой!!!
// Названия перменных не должны повторять зарезервированные слова в языке JS, например error,
// promt, alert и др.
// Перменные состоящие из нескольких слов записываются в формате CammelCase
// Важно назвать переменные осмысленно, ведь над ним в будущем будут работать другие люди

// Переменные let const видны только в блоке кода ограниченного круглыми скобками
// создадим объект и поменстим в него переменную
/* {
	let visible1 = 'noVisible';
	const visible = 'noVisible';
	console.log(visible, visible1); // получим noVisible noVisible - все ок
} */

// console.log(visible, visible1); // если запросим за пределами {}
// то получим ощибку visible is not defined т.е переменная не найдена


// Старый формат записи имени переменных и его проблемы

// Ранее для обозначения переменных использовалось ключевое слово var
// Данный формат записи переменных ни при каких обстоятельствах 
// мы не должны использовать в своем коде

/* console.log(name); // пытаясь оюратиться к переменной до ее объявления мы получим 
undefined var name = 'Ivan'; */
// Т.е. мы получаем не ошибку, а undefined данная переменная видна еще до ее объявления
// такое поведение при использование var называется hoisting (всплытие переменных)
// данное поведение может привести к очень не приятным и трудно отлавливаемым ошибкам

// Переменная созданная с помощью var видна и за пределами блока кода 
// ограниченного {}, т.е. переменная как бы "всплывает" в глобальную область видимости
// и это очень плохо с точки зрения логики
/* {
	var current = 10;
}
console.log(current); //выдаст 10 т.е. ошибки не будет т.к перменная "всплыла"  
// в глобальную область видимости */

// В старом стандарте JS можно было создать переменную без ее объявления через ключевое слово
// var
// Пример
/* a = 20;
console.log(a); */


// Современный формат записи кода используя директиву 'use strict';
// Данная деректива всегда записывсается в начале JS файла и говорит ему 
// что мы работатем в современном режиме JS, где уже не работают некоторые неточности,
// которые были в с тарых стандартах JS

// В новом формате используя строгий режим мы не можем объявлять переменные 
// не используя ключевых слов let или const
// Пример
/* "use strict";
 b= 20;
console.log(b); // получим ошибку ReferenceError: b is not defined */


/// ТИПЫ ДАННЫХ В JS

// Первая категория типов данных - простые типы(примитивы)

// Числа -  1, 2, 3
// Строки "string" - "name" это набор данных, которые мы можем описать словами
// Логический тип (bololean) - true / false это либо правда либо ложь
// null - специфический тип данных, это когда чего то-то просто не существует
// undefined - специфический тип данных, когда что-то существует, но у него нет значения
// Symbol -  представляет собой уникальный идентификатор.
// BigInt - тип данных отображающий большие числа (больше чем 2 в 53 степени)

// Вторая категория типов данных - комлексные типы или Объекты

// Подкатегория 1 - Спец объекты:          // Подкатегория 2 - Обычные объекты       
// Массивы []
// Функции function ()
// Объект даты
// Регулярные выражения
// Ошибки

// Разберем каждый из типов данных в частности:


// Тип данных Числа 

/* let number2 = 2;
let number3 = 4.5; // для дробных чисел используется именно точка, а не запятая */
// К числам относятся числовые значения, которые относятся к данному типу данных
// Пример
// Infinity (бесконечность) - числовое значение, получаемое при делении числа на 0
/* console.log(4 / 0); // выдаст Infinity (бесконечность)
console.log(-4 / 0); // выдаст -Infinity (минус бесконечность), получим при делении */
// отрицательно числа на 0
// NaN (Not a Number - не число)  - числовое значение получаемое в результате операции, 
// которая не подлежит математической логике
/* console.log(4 * "qwerty"); //выдаст NaN (не число)
// НО!!!
console.log(4* "111"); //выдаст строку '444' ВАЖНО помнить об этом!!! */


// Тип данных Строки

// Обязательным отрибутом строки являются кавычки, такие как: 
// Одинарные '', 
// Двойные "",
// Косые (бэктики) `` (косые кавычки используются для интерполяции 
// строк `qwerty ${43}`)

// Какаие кавычки использовать одинарные или двойные определяется стилистикой проекта,
// либо правилами заведенными в компании

/* const persone = "Alex"; */
// используя оператор typeof проверим тип данных присвоенных переменной persone
// Оператор typeof возвращает строку, указывающую тип операнда.
/* console.log(typeof(persone)); //выдаст "string" - строка */

/* const persone2 = `David`; // задание строк с помощью косых кавычек
console.log(typeof(persone2)); //выдаст "string" - строка */

/* const number4 = "888";  //строки помгу содержать в себе и цифры
// в случае если мы запишем цифры в кавычках, то тип данных у них будет не number, а string
console.log(typeof(number4)); //выдаст "string" - строка */


// Тип данных Логический тип данных bololean

/* const bool = true; // правда
const bool2 = false; // ложь */


// Тип данных null

// null - специфический тип данных, это когда чего то-то просто не существует

// Не объявляя перменную something попробуем вывести ее в консоль

/* console.log(something); // получим ошибку ссылочного типа 
// ReferenceError: something is not defined
// т.е. код не может сослаться на несуществующую переменную something */


// Тип данных Undefined 

//undefined -специфический тип данных, когда что-то существует, но у него нет значения

/* let a; // мы объявили переменную, но не присовили ей никакое значение 
console.log(a); // консоль нам выдаст undefined, т.е. перменная есть, 
//но ее значнеие не найдено */


// Тип данных Объект

// Объект - это коллекция данных, ключевая единица в JS
// данную струкутуру можно использовать для хранения абсолютно любых типов данных.
// Данные в объекте хранятся в формате ключ: значение и называются свойствами объекта.
// Так же в объекте могут содержаться какие-то дейсвтия - они называюися методы.
// Для создания объектов используются {}

/* const obj = {
	a: 23,
	b: "qwerty",
	c: [1, 3, 'asdfg'],
	isMaried: false
};  */
// Для доступа к определенному значению свойства объекта, мы долны обратиться к нему через
// имя объекта, а далее через точку указать ключ
// или черз квадратные скобки указать ключ заключенный в кавычки
// Пример
/* console.log(obj.a);  // через точку обращаемся к значению свойтсва a  - выдаст 23
console.log(obj['a']); // // через ['a'] обращаемся к значению свойтсва a  - выдаст 23 */

// Чтобы обратиться к элементу массива, который является значением определенного
// свойства объекта нужно так же указать имя объекта, затем через точку имя своства, 
// а затем в квадратных скобках указать порядковый индекс элемента массива
/* console.log(obj.c[2]); //выдаст строку 'asdfg'
// Так же можно это сделать используя только квадратные скобки
// Пример
console.log(obj["c"][1]); //выдаст число 3 */

// Частным случаем объекта явлется МАССИВ

// ВАЖНО!!! Массив это НЕ отдельный тип данных, а именно частный случай объекта
// Массив это структура для хранения данных, которые идут СТРОГО!!! по по порядку
// Во внутрь массива, точно так же как и во внутрь объекта можно положить любой тип данных
/* let arr = ['pic1.png', 'pic2.png', 'pic3.png', 'pic4.png', {}, [], 454, NaN]; */

// Для того, чтобы обратиться к определенному элементу массива нужно указать его имя, 
// а затем в квадратных скобках указать порядковый индекс элемента этого массива
// Пример

/* console.log(arr[4]); // выдаст элемент массива arr с порядковым индексом 4 - это 
// пустой объекn {}
console.log(arr[0]); // выдаст элемент массива arr с порядковым индексом 0 - это 
// строка 'pic1.png' */
// ВАЖНО!!! В программировании нумерация начинается не с единицы (1), а с нуля (0)

//Для доказательства, что массив это частный случай объекта, а не отдельный тип данных
//рассмотрим его более детально

//Объект преставляет собой стурктуру с данными хранящимися в формате ключ: значение

// В массиве ключами будут являться его порядковые индексы 0, 1, 2, 3, 4 и т.д.
// А значенимями свойств будут являться сами элменты массива 
/* //свойства:  ключ №0      ключ №1     ключ №2     ключ №3    ключ №4
let arr1 = ['pic1.png', 'pic2.png', 'pic3.png', 'pic4.png',    {},        [], 454, NaN]; */


/// ВЗАИМОДЕЙСТВИЕ С ПОЛЬЗОВАТЕЛЕМ

// Способ №1 с помощью функции интерфейсa браузера alert

// Функция интерфейса браузера alert показывает сообщение в модальном окне браузера 
// и ждёт, пока пользователь нажмёт кнопку «ОК».
// Функция интерфеса alert чаще всего используется для того, 
// чтобы предупредить пользователя о чем-то важном.
// ВАЖНО!!! отметить, что данная функция будет работать ТОЛЬКО в браузере,
// в консоли VSCode она работать не будет. Вылетающее окно будет невозможно застилизовать.

/* alert("Привет user"); // вылетит модальное окно со строкой "Привет user" и кнопокой Ok */

// Способ №2 с помощью функции интерфейсa браузера confirm

// Функция интерфейса confirm отображает модальное окно с текстом вопроса question 
// и двумя кнопками: OK и Отмена.
// ВАЖНО!!! отметить, что данная функция будет работать ТОЛЬКО в браузере,
// в консоли VSCode она работать не будет. Вылетающее окно будет невозможно застилизовать.

/* confirm("Вам есть 18 лет?"); // вылетит модальное окно со строкой-вопросом
// "Вам есть 18 лет?" и кнопоками Ok и Отмена */

//Так же мы можем записать ответ пользователя в перменную

/* const result = confirm("Вам есть 18 лет?");
// после чего полученные данные мы сможем использовать в дальнейшем
console.log(result); // в консоли будет булиновое значение или 
// true в случае, если пользователь нажмет кнопку Ok или 
// false в случае, если пользователь нажмет кнопку Отмена */

// Способ №3 с помощью функции интерфейсa браузера prompt

// Функция интерфейса prompt отобразит модальное окно с текстом, 
// полем для ввода текста и кнопками OK/Отмена.
// Данная функция необходима, для получения информации от пользователя,
// которую он введет в поле для ввода текста. Полученную инфу можно будет записать в 
// переменную и использовать ее в дальнейшем, к примеру внося инфу в БД.

/* const answer = prompt("Сколько будет 2 + 2?", ""); // после вопроса пользователю */
// мы ставим запятую, окрываем ковычки и оставляем их пустыми, либо
// вставляем дефолтный ответ (placeholder), который пользователь сможет стереть 
//и написать свой ответ.
// Пример 
/* const answer1 = prompt("Сколько будет 2 + 2?", "4, 5 или 6?");
console.log(answer);
console.log(answer1);
// ВАЖНО!!! Все данные приходящие от пользователя всегда будут иметь тип данных string
// вне зависимости от способа их получения.
console.log(typeof(answer1)); // выдаст string - тип строка */

// Для того чтобы преобразовать строковый тип данных string в числовой number
// можно использовать оператор унарный плюс +, который ставится напрмер перед комадой prompt
// Унарный + ставится всегда перед чем-то. 
// Унарный + использует только один аргумент для своей работы
/* const answer2 = +prompt("Сколько будет 5 + 12?", "4, 5 или 6?");

console.log(typeof(answer2)); // выдаст number
console.log(answer2 + 4); // если пользователь введет число то в консоль выдаст результат
// сложения числа которе ввел пользователь и 4. */

// Зададим вопросы пользователю и запишем его ответы в массив arr2
/* const arr2 = [];
// По порядку обратимся к порядковым индексам массива arr2 и запишем в них данные
// полученные от пользователя
arr2[0] = prompt("Как Вас зовут?", ""); 
arr2[1] = +prompt("Cколько вам лет?", ""); 
arr2[2] = prompt("Какие языки программирования вы знаете?", "");
arr2[3] = +prompt("Сколько лет вы программируете на JS", "");

console.log(arr2); // в консоль выведем получивышийся массив arr2 c ответами пользователя
console.log(typeof(arr2)); // выведет object, что еще раз подтверждает, что массив - это
// частный случай объекта. */

// Одним из первых методов используемых в JS был document.write
// Метод document.write – один из наиболее древних методов добавления текста к документу, но
// заменяет все содержимое сайта и в реальных проектах не используется.
// Мы можем использовать данный метод для тестов, чтобы к примеру вывести на страницу массив
// с ответами от пользователя.
/* document.write(arr2); */
// ВАЖНО!!! Функции интерфейса alert, confirm и prompt блокируют построение страницы до того
// момента пока они не будут выполнены. 

// ВАЖНО!!! Оффтоп НО, если вывести тип данных переменной, которой присвоен 
// специфический тип данных null обозначающий то, чего не существует консоль нам высдаст 
// object
/* const nothing = null;
console.log(typeof(nothing));
// ЭТО ЯВЛЯЕТСЯ ПРИЗНАННОЙ ОШИБКОЙ В JS. null является отдельным специфическим типом данных. */


/// ИНТЕРПОЛЯЦИЯ в JS

// Ранее для того, чтобы вставить в строку значнеие переменной использовалась
//конкатенация (склеивание) строк.
// Пример
// Для того чтобы сформировать URL путь в отдельную категорию игрушки пропишем следующее
/* const category = "toys";
//Теперь выведем в консоль путь в категорию игрушки старым методом используя конкатенацию
console.log("https://www.storeyourtoys.com/" + category);  */

// Интерполяция позволяет вставлять во внутрь строки значение пеперменной при помощи
// косых ковычек и ${}
// Cформируем тот же самый путь в категорию игрущки используя интерполяцию и вставим значение
// переменной category непосредственно в саму строку используя косые кавычки (бэктики) и ${}
/* console.log(`https://www.storeyourtoys.com/${category}`); */

// Используя интерполяцию можно получить данные от пользователя, записать их в переменную,
// а затем вставить значние переменной например в alert.
/* const nameUser = prompt("Как тебя зовут?", "");
alert(`Привет, ${nameUser}!`);
*/


/// ОПЕРАТОРЫ В JS

// Оператор + стоит особняком среди других операторов таких как:

// сложения +, 
// вычетания -,
// умножения *,
// деления /

// Если оператор сложения + применить к 2-ум строкам, то эти две строки склеятся между
// собой. 
// Даже если к строке прибавить число, на выходе будет срока.
// Данная операция называется конкатенация (склеивание).

// Пример

/* const row1 = "this is row one";
console.log(row1 + " this is row two"); //строка из переменной row1 склеится 
// со строкой " this is row two", на выходе будет this is row one this is row two
console.log(row1 + 1); // на выходе будет this is row one1. 
console.log(typeof(row1 + 1)); // Выдаст string - строка */
// Если мы захотим преобраховать строку в число, посредством унарного +, 
// и сложим получившееся число с другим числом, то

/* console.log(+"row3" + 4); //на выходе получим NaN (не число) т.к. мы выполняем дейтсвие,
// которое не подлежит математической логике, 
// т.к. мы пытаемся преобразовать буквы в число. */

//Но если мы попытаемся преобразовать число с типом данных string и прибавть к нему другое 
// число, у нас все получится
/* console.log(+"5" + 4); // на выходе получим 9, т.к. 5-ка из строки превратилась в число */

// Операторы инкремента ++ и декремента --

// Операторы инкремента ++ и декремента -- слжат для укорочения нашего кода

// Оператор инкремента ++ увеличивает значение на единицу

// Оператор декремента -- уменьшает значение на единицу

// Важно!!! Частый вопрос на собесодованиях - 
// Чем отличается перфиксная форма записи инкремента и декремента от постфиксной

// Оветим на данный вопрос на примере

/* let incr = 5,
	decr = 10;

incr++; // постфиксная форма записи инкремента
decr--; // постфиксная форма записи декремента

console.log(incr); // на выходе будет 6
console.log(decr); // на выходе будет 9

++incr; // префиксная форма записи инкремента
--decr; // префиксная форма записи декремента

console.log(incr); // на выходе будет 6
console.log(decr); // на выходе будет 9 */

// и вроде как отличий никаких нет НО!!!

//САМОЕ ВАЖНОЕ!!!
//Если мы поставим знаки инкремента и декремента прямо во время их использования в console.log
// картина будет совсем иная

/* let incr1 = 10,
	decr1 = 20;

console.log(incr1++); // на выходе будет 10, т.е. ничего не извменится
console.log(decr1--); // на выходе будет 20, т.е. ничего не извменится

// НО ЕСЛИ ЗАПУСТИТЬ console.log еще раз

console.log(incr1++); // на выходе уже будет 11, т.е. инкремент уже сработал 
console.log(decr1--); // на выходе уже будет 19, т.е. инкремент уже сработал  */ 
	 
// В случае, если мы используем инкремент и декремент в постфиксной форме записи
// прямо сразу в console.log или еще где-то, то сначала
// нам возвращается первоначалльное значение, а затем уже увеличенное или 
// уменьшенное на единицу

// В префиксной форме записи ситацация совершенно противоположная.
// Нам СРАЗУ возвращается увеличиенное или уменьшенное на единицу значение

/* let incr2 = 10,
	decr2 = 20;

console.log(++incr2); // на выходе будет 11
console.log(--decr2); // на выходе будет 19 */

// В циклах оперторы инкремента и декремента будут использоваться очень часто. 

// Как и в математике в JS применятся операторы 

// больше >
// меньше <
// больше либо равно >=
// меньше либо равно <=
// равно ==              // в JS одинарный знак = это оператор присваивания, а не сравнения
// не равно != (не строгое сравнение) !== (строге сравнение учитывая тип данных)
// логический оператор И - записывается как два амперсанта &&
// логический оператор ИЛИ - записывается как два вертикальных слеша ||
// побитовые опреаторы (в данном курсе мы их затрагивать не будем)
// Оператор отрицания ! обращает значение на противополжное, правду в ложь, ложь в правду
// возврат остатка от деления двух чисел %



// Пример использования возврата остатка от деления двух чисел %

/* console.log(5 % 2); // на выходе будет 1, т.к. 5-ка делится на 2 ровно 2 раза, в остатке 1 */

// Подробнее об операторе не строгого равенства == и строгого равенства ===

// Не строгое сравнение == это когда при сравнении не учитывается тип данных

/* console.log(2 * 4 == "8"); // на выходе будет true, т.е. тип данных не учитывается, 
// учитывается только значнеие и число 8 равно сроке со значением 8. */

// Строгое сравнение === это когда при сравнении учитывается тип данных

/* console.log(2 * 4 === "8"); // на выходе будет false т.к. тип данных уже учитывается, 
// и число 8 не равно сроке со значением 8. */

// Подробнее об логических опретаторах И && и ИЛИ ||

// Логический оператор И && работает только тогда, когда два или больше значений 
// являются правдивыми выражениями, т.е. И это правда И это правда

// Пример
// Проверим, что какая-то галочка на странице отмечена, и какое-то модальное окно закрыто
/* const isChecked = true,
	  isClosed = true;
console.log(isChecked && isClosed); // на выходе будет true, т.к. и первое выражение правдиво
// и второе выражение правдиво. */

/* // В случае если 
const isChecked1 = true,
	  isClosed1 = false;
console.log(isChecked1 && isClosed1); // на выходе будет false, т.к. первое выражение правдиво,
// а второе выражение уже не правдиво. */

/* const isChecked2 = false,
	  isClosed2 = false;
console.log(isChecked2 && isClosed2); // на выходе будет false, т.к. и первое выражение 
// не правдиво, и второе выражение не правдиво. */

// Логический оператор ИЛИ || работает тогда, когда одно из значений 
// является правдивым выражением, т.е. ИЛИ это правда ИЛИ это правда

/* const isChecked3 = true,
	  isClosed3 = true;
console.log(isChecked3 || isClosed3); // на выходе будет true, т.к. первое выражение правдиво,
// а второе выражение уже не важно правдиво или нет. */

/* const isChecked4 = false,
	  isClosed4 = true;
console.log(isChecked4 || isClosed4); // на выходе будет true, т.к. второе выражение правдиво,
// а певрое уже не важно правдиво или нет. */

/* const isChecked5 = false,
	  isClosed5 = false;
console.log(isChecked5 || isClosed5); // на выходе будет false, т.к. и первое выражение 
// не правдиво, и второе выражение не правдиво. */

// Оператор отрицания !

//Оператор отрицания ! обращает булинове значение в противоположное, 
//правду в ложь, ложь в правду
/* console.log(!(false)); // на выходе будет true
console.log(!(true)); // на выходе будет false */

// Оператор не равно !=

/* console.log(2 + 2 * 2 != "6"); // на выходе получим false, т.к. если не учитывать тип данных
// то число 6 равно строке "6" */

/* console.log(2 + 2 * 2 !== "6"); // на выходе получим true, т.к. если учитывать тип данных
// и сравнивать строго, то число 6 не равно строке "6" */

/* console.log(2 + 2 * 2 != 7); // на выходе получим true, т.к. число 6 не равно числу 7 */

// Порядок выполнения операторов
// Табличка приоритетов использования кодом операторов
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#table


/// СИСТЕМА КОНТРОЛЯ ВЕРСИЙ Git и СЕРВИС ХРАНЕНИЯ УДАЛЕННЫХ РЕПОЗИТОРИЕВ GitHub

// Git - это система контроля версий для проектов и создания контрольных точек.
// GitGub - это удаленное хранилище репозиториев.
// Система Git позволяет сохранять контрольные точки буквально за несколько команд  
// Все контрольные точки и изменения в проекте можно сохранять в репозитории, который позволит:
// посмотреть где, что и когда было изменено в проекте
// откатиться на старую версию проекта
// снова вернуться на новую версию проекта
// Так же Git позволяет экономить память, т.к. статичные (не измененные) файлы не копируются
// снова и снова.
// С репозиторием могут работать несколько человек, над большими реальными проектами, как 
// правило, трудится целая команда разработчиков.

// Даже если работать над проектом в одно лицо, сохранение изменений в репозиторий чрезвычайно
// важно, т.к. с компом может случиться все что угодно, либо закзачик может попросить вернуть
// те изменения, которые были несколько месяцев назад.

//Порядок установки Git'a

// 1) Скачать последнюю версию Git c сайта https://git-scm.com/
// 2) Туториал как пользоваться Git'ом можно посмотреть на https://githowto.com/ru
// 3) После установки Git'a можно юзать GUI (Графический интерфейс пользователя) 
// данное меню появляется если нажать правой кнопокой на любом файле (способ не удобен)
// 4) Можно использовать командную строку cmd. Чтобы попасть в нужную папку, а затем
// использовать Git c ее содержимым нужно набрать команду cd и через пробел указть путь
// который ведет к нужным файлам.
// 5) Вместо командной строки cmd, можно так же использовать PowerShell.
// 6) !!! НО Мы будем юзать Git прямо в VSCode!!!

// В VScode есть тот же интерфейс что и в командной строке cmd или PowerShel
// Отвечает за это вкладка Терминал.

// Порядок работы с Git'ом
// 1) Для инициализация работы Git'а в терминале набираем команду git init
// мы получим ответ Initialized empty Git repository in и в папке с проектом паявится 
// скрытая папка .git - это и есть наш репозиторий.
// 2) Необходимо законфигурировать файлы проекта:
// Конфигурировать файлы мы можем как локально так и глобально
// Глобальная конфигурация (настройки для всех файлов компьютера) позволяет создвать все 
// проекты от нашего имени.
// Локальная конфигурация (настройки для файлов отдельного проекта) позволяет создвать 
// проект указав уже любое доругое имя разработчика проекта. 
// При указании локальной конфигурации для конкретного проекта глобальные 
// данные уже не будут распространяться на него.

// Пропишем две конфигурационные команды, чтобы представить себя:
// Для локальной конфигурации прописываем следующее 
// git config --local user.name "F1icker"
// git config --local user.email fl1ck@yandex.ru (уже без кавычек)

// Для глобальной конфигурации прописываем следующее 
// git config --global user.name "F1icker"
// git config --global user.email fl1ck@yandex.ru (уже без кавычек)

// У Git репозитория есть три состояния файлов 
// 1-ое состояние - это когда фалы просто созданы
// 2-ое состояние - это когда Git следит за определенными файлами (файлы попали в index)
// 3-е состояние файлов - это когда Git создал контрольную точку к которой мы сможем вернуться
// и посмотреть какие были изменения, как работал проект в данной контрольной точке и т.д.
// Данное состояние называется commit

// Для того чтобы посмотреть в каком состоянии находятся фалы в проекте пропишем команду
// git status

// Красным цветом подсвечены все файлы, которые етсь в проекте, 
// Git за ними не следит (состояние 1)

// Чтобы переключить ветку с master на main необходимо прописать команду 
// git branch -M main

// Чтобы перевести файлы проекта во 2-ое состояние (добавить их в index) пропишем команду
// git add -A 
// Все файлы за которыми Git не следил, будут добавлены в отслеживание их цвет станет зеленым
// Если к примеру нужно добавить в отслеживание новые файлы пропишем команду
// git add имяНовогоФайла.расширениеФайла
// или 
// git add *.расширение файла (тогда будут добавлены все не остлеживающиеся фалы с данным
// расширением)
// Чтобы сбросить последнее измененеие файла можно пропсаить команду
// git restore имяНовогоФайла.расширениеФайла, это аналог сочетнаия клавишь Ctrl+Z

// Чтобы перевести файлы в 3-е состояние и создать контрольную точку пропишем команду
// git commit -a -m"first commit"
// Чтобы сбросить последний commit до предыдущего commit'a можно прописать команду
// git checkout имяНовогоФайла.расширениеФайла

// Чтобы посмотреть какие commit'ы были сделаны пропишем команду 
// git log

// Для выгрузки commit'ов на удаленный репозиторий в GitHub нужно:
// 1) Для начала нужно в учетке GitHub создать новый репозиторий
// 2) Прописать имя репозитория
// 3) Прописать описание Description(не обязательно)
// 4) Выбрать профиль репозитория Публичный Public (доступен всем) или Приватный Private
// 5) Прописываем удаленный репозиторий, в который будут выгружены наши Commit'ы
// для этого прописываем команду 
// git remote add origin https://github.com/F11cker/JS_lecture_notes.git
// После ввода данной команды наш локальный репозиторий (на нашем компе) 
// будет связан с удаленным репозиторием на GitHub
// Чтобы запушить commit'ы на GitHub прописываем команду
// git push -u origin main

// Кратко все команды по порядку:

// git config --local user.name "F1icker" (только в начале работы над новым проектом)
// git config --local user.email fl1ck@yandex.ru (уже без кавычек) (только в начале работы)
// git status 
// git branch -M main
// git add -A 
// git commit -a -m"first commit"
// git log
// git remote add origin https://github.com/F11cker/JS_lecture_notes.git (только в начале работы)
// git push -u origin main (для следующих commit'ов можно импользовать команду git push)

// Работа с репозиторием на GitHub с разных аккаунтов
// Например с работа с репозиторием с домашнего компа и с рабочего

// 1) Клонирование репозитория с которым ведется работа
// Для этого есть два способа:
// Способ №1 - зайти на GitHub в нужный репозиторий и внутри нажать зеленую кнопку
// Code и далее скачать ZIP архив с проектом
// Способ №2 с зайти в терминал VSCode и восопользваться командой 
// git clone + путь к репозиторию который мы хотим скопировать
// для того, чтобы клонировать данный репозиторий. (Это наиболее правильный способ)
// Для того, чтобы зайти в нужную папку на том компе, на которм в данный момент ведется работа
// нужно набрать следующие команды в терминале:
// cd..
// cd имяНужнойПапки
// git clone https://github.com/F11cker/JS_lecture_notes.git  имяНужнойПодПапки
// Клонирование репозитория автоматически связывает новый локальный комп 
// с удаленным репозиторием. 
// Тем самым мы сразу можем делать commit'ы в проекте и пушить их в данный удаленный реп.
// Для этого можно сразу набирать команду 
// git push

// 2) Чтобы при возвращении на, к примеру, домашний компьютер получить все те изменения проекта,
// которые были сделаны на рабочем компьютере и работать с его последней версией нужно ВСЕГДА
// перед началом работы прописывать команду 
// git pull
// В случае, если мы не пропишем команду git pull перед началом работы с проектом и попытаемся
// запушить созданные нами commit'ы мы получим ошибку, т.к. в удаленном репозитории может
// оказаться более новая версия проекта чем у нас на компьютере, на которым мы в данный момент
// работаем.
// ВСЕГДА ПРОПИСЫВАЙ git pull ПЕРЕД НАЧАЛОМ РАБОТЫ!!!

// В случае если вознимает ситуация слияния (Merge) локального и удаленного репозитория то 
// 1) Задаем сообщение commit'a
// 2) Прожимаем 2 раза Ctrl + C
// 3) Прописываем команду :wq! + Enter
// 4) Git push

// Игнорирование файлов при работе Git и GitHub (используем файл .gitignore)

// При работе с проектом, чаще всего мы не хоим пушить в удаленный репозиторий различные 
// рабочие файлы напрмер папку node_modules

/// ПРАКТИКА №1

// Задание на урок:

//1) Создать переменную numberOfFilms и в неё поместить ответ от пользователя на вопрос:
// 'Сколько фильмов вы уже посмотрели?'

//2) Создать объект personalMovieDB и в него поместить такие свойства:
	// - count - сюда передается ответ на первый вопрос
	// - movies - в это свойство поместить пустой объект
	// - actors - тоже поместить пустой объект
	// - genres - сюда поместить пустой массив
	// - privat - в это свойство поместить boolean(логическое) значение false

//3) Задайте пользователю по два раза вопросы:
	// - 'Один из последних просмотренных фильмов?'
	// - 'На сколько оцените его?'
// Ответы стоит поместить в отдельные переменные
// Записать ответы в объект movies в формате: 
/*     movies: {
		'logan': '8.1'
	} */

// Проверить, чтобы все работало без ошибок в консоли 

// Выполним задачу №1
/* const numberOfFilms = +prompt("Сколько фильмов вы уже посмотрели?", "");
// Выполним задачу №2
const personalMovieDB = {
	count: '',
	movies: {},
	actors: {},
	genres: [],
	privat: false
};

personalMovieDB.count = numberOfFilms;
// Выполним задачу №3
const lastFilms = prompt("Один из последних просмотренных фильмов?", ""),
	  rating = +prompt("На сколько оцените его?"),
	  lastFilms1 = prompt("Один из последних просмотренных фильмов?", ""),
	  rating1 = +prompt("На сколько оцените его?");

personalMovieDB.movies[lastFilms] = rating; 
personalMovieDB.movies[lastFilms1] = rating1;
// Записывать данные в объект который лежит внутри другого объекта лучше через [], 
// а не через точку.
console.log(personalMovieDB); // выведем все в консоль. */

/// УСЛОВИЯ в JS

// Все условия начинаются с оператора if (если)

// if (в круглых скобках пишем условие, которое хотим проверить) {
		// в фигурных скобках записываем то, что случится, если условие верно (true)
		// напрмер console.log("ok!");
// } else {   // Вторая часть условия начинается с else (иначе)
	// в фигурных скобках записываем то, что случится, если условие if не верно (false)
	// напрмер console.log("НЕ ok!");
// }
// Т.е. услвие внутри круглых скобок должно быть преобразованно к булиновому типу true / false

// Пример
if (9 == 9) {
	console.log("ok!");
} else {
	console.log("Error!");
}

// В случае, если в условие поместить одно число, отличное от 0, 
// то оно будет всегда будет возвращать true. 
// Число отличное от 0 в своем логическом контексте всегда true

// Пример
if (4) {
	console.log(true); // вернет true
} else {
	console.log(false);
}

// Но если поместить 0, то оно вернет false 
// 0 в своем логическом контексте всегда false 
// Пример
if (0) {
	console.log(true); 
} else {
	console.log(false); // вернет false
}

// Вложенность условий

const num = 50;

if (num < 49) {
	console.log("Error!"); 
} else if (num > 100) { // условие if не правда, проверяем следующее (это и есть вложенность)
	console.log("too much!");
} else {
	console.log("Ok!");
}                   

// Запись условий при помощи тернарного оператора

// Тернарный  оператор - единственный оператор в JavaScript, 
// принимающий три операнда: условие, за которым следует знак вопроса (?), 
// затем выражение, которое выполняется, если условие истинно (true), 
// сопровождается двоеточием (:), и, наконец, выражение, которое выполняется, 
// если условие ложно (fasle). 
// Он часто используется в качестве укороченного варианта условного оператора if.
// Синтаксис следующий:
// В круглых скобках пишем условие, которое хотим проверить
// После знака вопроса ? прописывается то, что произойдет, если условие вернет true
// После знака двоеточия : прописывается то, что произойдет, если условие вернет false

// Пример
/* const num1 = 40;
(num1 === 40) ? console.log("Ok!") : console.log("Error!");  */

///////////////////////////////////////////////////////////////////////////////////////////
// ВАЖНЫЙ ОФТОП

// 4 + 4 // в данном случае + это бинарный оператор (принимает 2 операнда)

// +"4"  // в данном случае + это унарный оператор (унарный плюс) (принимает 1 операнд)

// условие ? выражение1 : выражение2 // ? и : в совокупности являются тернарным оператором
////////////////////////////////////////////////////////////////////////////////////////////

// Конструкиця switch. 
// ВАЖНО!!! Конструкция switch ВСЕГДА ИДЕТ НА СТРОГОЕ СРАВНЕНИЕ!!! ===
// Для того чтобы избежать большого количества вложенности условий существую конструкция
// switch, которая поддерживает сразу неслько проверок и условий
// Синтаксис следующий
// В круглые скобки(в условие) мы помещаяем объект того что мы будем сравнивать
// и что проверять (просто передаем имя переменной)
// В фигурных скобках прописываем директиву case и через пробел записываем то, 
// с чем будем сравнивать значение нашей переменной.
// Ставим знак двоеточия : и после него пишем то, что произойдет если условие вернет true
// После каждого действия мы должны записать ключевое слово break и ставить знак ;
// В конце записывается действие по умолчанию default, которое сработает, 
// если не один из case'ов не вернет true.
// После так же прописываем break;

const num2 = 50;
switch (num2) {
	case 49:
		console.log("error");
		break;
	case 100:
		console.log("error");
		break;
	case 50:
		console.log("ok!");
		break;
	default: 
		console.log("nothing");
		break;  
}

// Со строками все работает точно так же, идет строгое сравнение.


/// Циклы

// Циклы - простой способ сделать какое-то однотипное действие несколько раз.

// В JS реализовываются 3-мя способами. Каждый из них исппользуется в зависимости от ситуации

// Способ №1 цикл while
// Дословно - ПОКА условие выполняется мы будем повторять какие-то действия
// Цикл while похож на условия.
let num3 = 50;

while(num3 <= 55) {     // в круглых скобках мы записываем условие
	console.log(num3); // в фигурных скобках мы записываем действия, которые будут выполняться 
	num3++;            // циклом пока условие не выполнится          
  
}

// Способ 2 цикл do
// Цикл do Сначала что-то делает, затем проверяет условия, и если необходимо выходит из цикла

let num4 = 80;

do {                   // сначала пишем ключевое слово do
	console.log(num4); // в фигурных скобках прописываем действия, которые будет выполнять цикл
	num4++;
} while(num4 < 85);    //Проверку условия размещаем под телом цикла

// Способ 3
// Цикл for - самый распространённый цикл 
// Синтаксис следующиий
// Пишем ключевое слово for
// Далее в круглых скобках прописываем условие состоящиее из 3-ех аргументов
// 1-ый аргумент это let i (итератор) задаем переменную с которой нвчинается цикл for
// 2-ой аргумент i < 8 (как пример) - это условие, при котором цикл for остановит свою работу
// 3-ий аргуммент - это шаг цикла for чаще всего используется инкремент. Пример i++
let num5 = 100;

for (let i = 0; i < 8; i++) {  // между аргументами условий цикла обязательно ставится знак ;
	console.log(num5);         // в круглых скобках записываются действия, 
	num5++;                    // которые будет выполнять цикл на каждой его итерации
}      
// Данный цикл можно сделать бесконечным если прописать i < 0, нужно быть с эти осторожным

// Иногда возникает необходимость закончить цикл досрочно, напрмер если i примет какое-то
// специфическое значение
// для этого используется ключевое слово break
// Пример

let num6 = 100;

for (let i = 0; i < 8; i++) { 
	if (num6 === 106) {
		break;                //ключевое слово break полностью прервет цикл
	}
	console.log(num6);         
	num6++;                 
} 

// Иногда возникает необходимость пропустить шаг цикла, напрмер если i примет какое-то
// специфическое значение
// для этого используется ключевое слово continue
// Пример

let num7 = 2;

for (let i = 0; i < 12; i++) { 
	num7++;                      // если выражение поставть после conosle.log - continue
	if (num7 === 5) {            // сработает как break
		continue;                // ключевое слово continue пропустит шаг цикла кода num7 будет === 5
	}
	console.log(num7);           // выдаст 3, 4, (5 пропустит), 6, 7 и т.д. 
				  
} 

// Важно не путать циклы с методами перебора forEach, filter, map

// Практика №2

// Задание 

// 1) Автоматизировать вопросы пользователю про фильмы при помощи цикла

// 2) Сделать так, чтобы пользователь не мог оставить ответ в виде пустой строки,
// отменить ответ или ввести название фильма длинее, чем 5 символов. Если это происходит - 
// возвращаем пользователя к вопросам опять

// 3) При помощи условий проверить  personalMovieDB.count, и если он меньше 10 - вывести сообщение
// "Просмотрено довольно мало фильмов", если от 10 до 30 - "Вы классический зритель", а если больше - 
// "Вы киноман". А если не подошло ни к одному варианту - "Произошла ошибка"

// 4) Потренироваться и переписать цикл еще двумя способами*/

// Код возьмите из предыдущего домашнего задания

/* const numberOfFilms2 = +prompt("Сколько фильмов вы уже посмотрели?", "");

const personalMovieDB2 = {
	count: '',
	movies: {},
	actors: {},
	genres: [],
	privat: false
};

personalMovieDB2.count = numberOfFilms2;
// Выполним задание №3
if (personalMovieDB2.count < 10) {
	alert("Просмотрено довольно мало фильмов");
} else if (personalMovieDB2.count >= 10 && personalMovieDB2.count < 30) {
	alert("Вы классический зритель");
} else if (personalMovieDB2.count >= 30) {
	alert("Вы киноман");
} else {
	console.log("error");
}

// Выполним задание №1
for (let i = 0; i < 2; i++) {
	const lastFilms2 = prompt("Один из последних просмотренных фильмов?", ""),
		  rating2 = +prompt("На сколько оцените его?", "");
	//Выполним задание 2
	if (lastFilms2 == "" || rating2 =="" || lastFilms2 == null || rating2 == null || lastFilms2.length > 5) {
		i--;
	} else  {
		personalMovieDB2.movies[lastFilms2] = rating2; 
	}
 
}  */

// Выполним задание 4
// При помощи цикла while
/* let i = 0;
while (i < 2) {
	const lastFilms2 = prompt("Один из последних просмотренных фильмов?", ""),
	rating2 = +prompt("На сколько оцените его?");
	//Выполним задание 2
	if (lastFilms2 == "" || rating2 =="" || lastFilms2 == null || rating2 == null || lastFilms2.length > 5) {
	i--;
	} else  {
	personalMovieDB2.movies[lastFilms2] = rating2;
	i++; 
}
} */

// При помощи цикла do ... while
/*  let i = 0;
do {
	const lastFilms2 = prompt("Один из последних просмотренных фильмов?", ""),
	rating2 = +prompt("На сколько оцените его?");
	//Выполним задание 2
	if (lastFilms2 == "" || rating2 =="" || lastFilms2 == null || rating2 == null || lastFilms2.length > 5) {
	i--;
	} else  {
	personalMovieDB2.movies[lastFilms2] = rating2;
	i++;
	}
} while(i < 2); */

/* console.log(personalMovieDB2); // выведем все в консоль.  */


/// ФУНКЦИИ В JS

// Функции являются основными «строительными блоками» программы.
// Функции - это наши действия в JS, они используют различные типы даннных и изменяют программу
// так как мы ей укажем.
// Функции значительно сокращают наш код. Мы можем написать одну функцию, а зетем вызывать
// ее сколько угодно раз.

// Пример обычный калькулятор это просто набор математических функций.

// Синтаксис Функции:
// Сначала прописываем ключевое слово function
// Прописываем или не прописываем имя функции (функция без имени - это анонимная функция)
// Ставим круглые скобки, в них мы передаем аргументы функции
// Ставим фигурные скобки, в них мы пропишем действия функции 
// Вызываем функцию обращаясь к ее имени и ставя круглые скобки showFirstMassege();
// Если мы передаем аргумент на вход функции например (text), сам текст мы указываем при
// вызове данной функции showFirstMassege("Hello everyone");

//Пример

function showFirstMassege (text) {
 console.log(text);
}

showFirstMassege("Hello everyone"); // при вызове функции она берет текст Hello everyone
// далее передает его аргументом (text) на вход функции, а функция совершает действие с аргументом
// в данном случае выводит в консоль текст Hello everyone за счет команды console.log
// Анонимная функция вызывается и используется прямо сдесь и сейчас только 1 раз
// ВАЖНО!! Имя функции должно быть глаголом с препиской того, над чем выполняется ее действие
// Аргументы функции - это данные на вход, функция будет использовать их внутри себя
// Аргументов, которые функция принимает на вход может быть множество, 
// они указываются через зяпятую (text, num, a, b)
// Как пример в куалькулятор мы передаем 2 числа 4 и 5 функция сложения будет их складывать

// Eще один пример функции - сложения 2-ух чисел
const a = 4;
const b = 5;

function addition (result) {
	console.log(result);       // выведет в консоль результат сложения чисел 5 и 4
   }

addition(a + b);

// Как ведут себя переменные внутри функции (объявленные внтури фигурных скобок)?
// Все что прописано в фигурных скобках это локальная область видимости 
// и мы не можем обращаться из глобальной области видимости (все что снаружи фигурных скобок)
// в локальную область (например к переменным) они будут просто не доступны. 
// Из глобальной области видимости не видно то, что лежит в локальной области.
// Пример:
function showMustGo() {
	let num = 5;
}

showMustGo();

console.log(num); // выдаст ошибку num is not defined, потому как мы не можем достучаться 
// из глобальной области до перменной num, которая существует локально внутри функции. 

// НО! из локальной области видимости функции мы спокойно можем обращатся к тому, что лежит
// в глобальной области видимости.
// Т.е. любая функция может брать и использовать внутри себя переменные, которые объявлены глобально.

// Пример
let num8 = 10;

function showNum() {
	num8 = 5;        // в теле функции возьмем глобальную переменную num8 перезапишем ее значние на 5
}
showNum();
console.log(num8);  // а затем выведем значение перменной num8 в консоль.

// Переменные с одинаковым именем созданные в глобальной и локальной области это
// разные переменные

let num9 = 10;             // переменная num9 объявлена глобално и видна во всем коде

function showNum() {
	let num9 = 15;         // переменная num9 объявлена и видна локально только в теле функции
	console.log(num9);     // на выходе будет 15, т.е. выведет значение локальной перменной
}
showNum();

console.log(num9);  // на выходе будет 10, т.е. выведет значение глобальной перменной
// ВАЖНО!!! Частый вопрос на собеседованиях!
// Замыкание функции - это сама функция вместе со всеми внешними пременными, 
// которые ей доступны. Причем функция берет в работу только последнее изменение 
// внешней переменной.

// Пошаговый путь работы функции:
// Функция showNum() после ее вызова, сначала передает аргумент на вход функции, если он есть
// Далее функция showNum1() ищет значение переменной num10 в локальной области
// В случае, если она не находит эту переменную в локальной области,
// она обращается в глобальную. 
// Т.е. команда console.log(num10) выведет значение глобальной переменной num10 = 11

let num10 = 11;                

function showNum1() {
	console.log(num10);        
}
showNum1();

// Функции могут возвращать нам значения при помощи ключевого слова return
// Как только функция увидит return она прекратит свое действие

function calc (a, b) {   // функция calc() принимает на вход 2 аргумента a и b
	return (a + b);	     // при помощи ключевого слова return функция calc()
}                        // возвращает результат сложения аргументов a и b
//возвращаемое значение возвращается к вызывающей области т.е. в calc(результат сложения)

console.log(calc(3, 6)); // каждый раз при вызве функции calc() мы передаем в нее аргументы
console.log(calc(5, 8)); // и она возвращает нам резульат их сложения
console.log(calc(1, 1));

// Код, который идет после ключевого слова retrun назвается мертвым Unreachable - он не работает
// и некогда не выполнится.

// Return возвращает значения из функции в глобальную область видимости
// Пример
function ret() {   // объявим функцию ret()
	const g = 50;  // зададим определение функции ret и объявим в ней переменную g = 50
	return g;      // функция ret() возвращает нам значение переменной g при ее вызове
}                  // в глобальную область видимости

const g2 = ret(); // объявим переменную g2 и присвоим ей вызов функции ret()
// после чего перменной g2 будет присвоено возвращаемое функцией ret() значение = 50
console.log(g2);  // на выходе будет 50

//Классификация функций в JS

//1) Function declaration
// Создается до начала выполнения скрипта, данную функцию можно вызывать перед объявлением
// Пример
console.log(foo(5, 6)); // т.е. мы вызваем функцию раньше, чем мы ее объявили

function foo(a, b) {
	return (a + b);
}

//2) Function expression
// Создается только тогда, когда до нее доходит поток кода, 
// данную функцию можно вызывать ТОЛЬКО после объявления переменной, которой она присвоена.
// Если вызвать функцию до объявления перменной, которой она присвоена получим ошибку
// переменная is not defined
// Пример

const foo2 = function (a, b) {
	return (a + b);
};

console.log(foo2(5, 6));

//3) Стрелочные функции (добавлены в стандарте ES6)
// Синтаксис
// Создаем переменную например c именем calc3
// Присваиваем ей следующую конструкцию (a, b) => {a + b};
// В круглые скобки записываются аргументы принимаемые функцией calc3 на вход
// После знака => в фигурных скобках {} прописывается определение функции, 
// т.е. то, что она будет делать
// Стрелочная функция не имеет контекста this
const calc3 = (a, b) => {
	console.log("1");
	return a + b;
};

// В случае, если исполняемый функцией код можно прописать в одну строку, 
// то фигурные скобки можно не использовать
// Пример

const calc4 = (a, b) => a + b;

// В случае если функция имеет 1 аргумент, то круглые скобки тоже можно не использовать
// Пример
const calc5 = a => a;


/// МЕТОДЫ И СВОЙСТВА У СТРОК И ЧИСЕЛ

// Методы - это вспомогательные функции.
// Методы являются вспмогательными функциями и они вызываются используюя ()

// Свойства - это вспомогательные значения. 
// Свойства никак не вызываются. Их прописывают после точки.

// Все названия методов и свойств можно найти в офф. документации.
// Кроме офф. документации можно воспользоваться браузером и получить их в консоли
// воспользовавшись командой console.dir
// Напрмер console.dir(Number)
// Открыть полученный глобальный объект и посмотреть методы и свойства примитива Number

// Свойство length позволяет позволяет посчитать длинну строки

const str = "test";      // объявим переменную str и присвоим ей строку test

console.log(str.length); // посчитаем кол-во символов в строке test при помощи свойства length
// на выходе будет 4

// Определенный символ из строки можно получить обратившись к его порядковому индексу

const str2 = "test2"; // объявим переменную str2 и присвоим ей строку

console.log(str2[2]); // обратимся к индексу 2 строки и на выходе получим букву s,
// которая соответсвует порядковому индексу 2 строки test2. Нумерация начинается с 0.

// В отличии от массива мы не можем заменить букву в строке обратившись к ее индексу
// Пример
/* const str3 = "test3"; //объявим переменную str3 и присвоим ей строку

str3[2] = "b"; // обратимся к индексу 2 строки и попытаемся поменять букву s на b

console.log(str3); // замена буквы s на b не сработает, на выходе также будет test3 */


// Свойство length так же позволяет посчитать кол-во элементов внутри массива

const arr8 = [12, 10, {}, [], "test"]; // объявим переменную arr8 и присвоим ей массив

console.log(arr8.length); //посчитаем кол-во элементов в массиве при помощи свойства length
// на выходе бует 5

// Свойство length позволяет за счет выражения length - 1 вернуть
// индекс последнего элемента массива

const arr9 = [12, 10, {}, [], "test"]; // объявим переменную arr9 и присвоим ей массив

console.log(arr9.length - 1); // вернет порядковый индекс последнего элмента массива arr9 = 4

// Метод изменения регистра строки to toUpperCase на заглавные буквы

const str10 = "Test"; // объявим переменную str10 и присвоим ей строку

console.log(str10.toUpperCase()); // обратившись к строке str10, и вызвав метод toUpperCase()
// на выходе получим строку TEST (т.е. в верхнем регистре)

console.log(str10.toLowerCase()); // обратившись к строке str10, и вызвав метод toLowerCase()
// на выходе получим строку test (т.е. в нижнем регистре)

console.log(str10);// Метод не изменяет значение той строки, к которй он применяется. 
//Метод возвращает новое значение, которые мы можем, к примеру, записать в другую переменную
// и использовать где-то дальше.

// Метод indexOf() (поиск подстроки) возвращает первый индекс, 
// по которому данный элемент может быть найден в массиве или -1, если такого индекса нет.
// Если проще, то метод позволяет найти кусок строки и сказать с какого индекса она начинается.

const str11 = "Some everything"; // объявим переменную str11  и присвоим ей строку

console.log(str11.indexOf('everything')); // выведет 5, потому как индекс строки
// с которого начинвается слово everything = 5. Нумерация начинается с 0.

// Данный метод чаще применяется для поиска в тексте опеределенного слова или значения.
//Пример
const str12 = "Some everything"; // объявим переменную str11  и присвоим ей строку

console.log(str12.indexOf('q')); // аругументом метода ndexOf передадим 'q', на выходе будет -1, 
//что значит, что искомой буквы q в тексте нет

// Изменения строк при помощи методов для этого существует 3 способа

// 1) Метод slice() принимает на вход 2 аргумента
// 1 аргумент start указывает на индекс символа строки с которого мы начнем вырезать ее кусок
// 2 аргумент end указывает на индекс символа строки на котором мы закончим вырезать ее кусок,
// НО уже НЕ ВКЛЮЧАЯ последний символ

const str4 = "qwerty 123 zxcvby";

console.log(str4.slice(11, 16)); // на выходе будет строка 'zxcvb' символ 'y' не будет учтен

// В случе, если нужно обрезать кусок начиная с какого-то индекса, а дальше не резать, т.е.
// вернуть всю остальную часть строки, 
// то мы указываем только 1 аргумент метода slice() - индекс с которого начинать.

const str5 = "qwerty 123 zxcvbytttttttttttt";

console.log(str5.slice(11)); // на выходе будет zxcvbytttttttttttt

// Метод slice поддерживает и отрицательные значения аргументов, тогда резка начинается с конца строки

const str6 = "yyyTTT";

console.log(str6.slice(-3)); // т.е. нумерация начинается слева направо, на выходе будет TTT

// Метод slice больше применим к массивам, для строк лучше использовать метод subString()
const arr6 = [1, 2, 5, 8, 11, 44];

console.log(arr6.slice(1, 4)); // на выходе вернет массив [ 2, 5, 8 ]

// 2) Метод subString()
// 1 аргумент start указывает на индекс символа строки с которого мы начнем вырезать ее кусок
// 2 аргумент end указывает на индекс символа строки на котором мы закончим вырезать ее кусок,
// НО уже НЕ ВКЛЮЧАЯ последний символ 
// Метод subString() НЕ поддерживает и отрицательные значения аргументов

const str7 = "qwerty 123 zxcvbytttttttttttt";

console.log(str7.slice(11)); // на выходе будет zxcvbytttttttttttt

// 3) Метод substr()
// 1 аргумент start указывает на индекс символа строки с которого мы начнем вырезать ее кусок
// 2 аргумент указывает какое кол-во символов строки мы вырезаем ПОСЛЕ индекса start 
// Т.е. данный метод указывает сколько символов нужно вырезать из строки, и на то с какого по порядку начать 
const str13 = "qwerty 123 zxcvbytttttttttttt";

console.log(str13.substr(2, 7)); // на выходе будет erty 12

// Методы чисел

// Для работы с числами в JS существет мини библиотека Math, которая существет внутри браузеров
// Для того чтобы посмотреть что в ней есть, можно к консоли с большой буквы прописать Math. (с точкой)

// Метод для округления чисел до ближайшего целого round()

const numOne = 3.5;

Math.round(numOne);

console.log(Math.round(numOne));

// Еще один метод для преобразования строк в числа - parseInt(). Работает даже если в строке есть буквы
// Метод parseInt() превращает число в другую систему изчисления. 
// Метод parseInt() обрезает дробные числа с типом данных строка до целого и возращает нам тип данных число
// ВАЖНО!!! не округляет, а именно обрезает текущее значение. 
const Str = "12.5px"; //напрмер мы получили размеры определенного элемента и присовили их переменнной Str

console.log(parseInt(Str)); // вернет нам 12. Метод парсит(вычленяет и строк числа и возвращает их)

//Метод parseFloat() возвращает нам числа из строк, 
// но в отличии от parseInt может вернуть нам их в десятичном варианте (с плавающей точкой). 

const Str1 = "12.5px"; //напрмер мы получили размеры определенного элемента и присовили их переменнной Str

console.log(parseFloat(Str1));

// Метод isNaN() проверяет свой аргумент и если он не число, возвращает нам true (правду)
// Пример 

const Str3 = "srtiiing";

console.log(isNaN(Str3)); // т.к. значение переменной Str3 не число, метод возвращает нам true(правду)

/// ПРАКТИКА №3.

/* Задание на урок:

1) Первую часть задания повторить по уроку

2) Создать функцию showMyDB, которая будет проверять свойство privat. Если стоит в позиции
false - выводит в консоль главный объект программы

3) Создать функцию writeYourGenres в которой пользователь будет 3 раза отвечать на вопрос 
"Ваш любимый жанр под номером ${номер по порядку}". Каждый ответ записывается в массив данных
genres

P.S. Функции вызывать не обязательно*/

// Код возьмите из предыдущего домашнего задания

// Выполним задание №1

// Переведем наше web-приложение в функциональный вид.
let numberOfFilms3;

function start() {
	numberOfFilms3 = +prompt("Сколько фильмов вы уже посмотрели?", "");

	while(numberOfFilms3 == "" || isNaN(numberOfFilms3 ) || numberOfFilms3 == null) {
		numberOfFilms3 = +prompt("Сколько фильмов вы уже посмотрели?", "");
	}
}

start();

const personalMovieDB3 = {
	count: numberOfFilms3,
	movies: {},
	actors: {},
	genres: [],
	privat: false
};

function detectPersonalLevel() {
	if (personalMovieDB3.count < 10) {
		alert("Просмотрено довольно мало фильмов");
	} else if (personalMovieDB3.count >= 10 && personalMovieDB3.count < 30) {
		alert("Вы классический зритель");
	} else if (personalMovieDB3.count >= 30) {
		alert("Вы киноман");
	} else {
		console.log("error");
	}
}

detectPersonalLevel();
// Выполним задание 3 первым способом
/* function writeYourGenres() {
	for (let i = 1; i <=3; i++) {  
		personalMovieDB3.genres[i-1] = prompt(`Ваш любимый жанр под номером ${i}`);       
		                
	}      
}
writeYourGenres(); */

// Выполним задание 3 вторым способом добавив внего проверку полученных от пользователя данных

function writeYourGenres() {
	for (let i = 1; i <=3; i++) {
		const genre = prompt(`Ваш любимый жанр под номером ${i}`);
		if (genre == "" || genre == null) {
			i--;
		}else {
			personalMovieDB3.genres[i-1] = genre;
		}
	}
}

writeYourGenres();

function rememberOfFilms() {
	for (let i = 0; i < 2; i++) {
		const lastFilms3 = prompt("Один из последних просмотренных фильмов?", ""),
			  rating3 = +prompt("На сколько оцените его?", "");
		//Выполним задание 2
		if (lastFilms3 == "" || rating3 =="" || lastFilms3 == null || rating3 == null || lastFilms3.length > 5) {
			i--;
		} else  {
			personalMovieDB3.movies[lastFilms3] = rating3; 
		}
	 
	} 
}

rememberOfFilms();
// Выполним задание 2 первым способом
/* function showMyDB() {
	if (personalMovieDB3.privat == false) {
		console.log(personalMovieDB3);
	}
}

showMyDB(); */

//Выполним задание 2 вторым способом - передав аргумент personalMovieDB3.privat в функцию showMyDB()

function showMyDB(hidden)  {
	if (!hidden) {                     // оператор отрицания ! поменяет false на true
		console.log(personalMovieDB3); // и в консоль выведет объект personalMovieDB3 
	}
}
showMyDB(personalMovieDB3.privat);





